<template page>
  <l-m src="./comps/icon-block.html"></l-m>
  <l-m src="@pui/button/button.html"></l-m>
  <style>
    :host {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      align-content: flex-start;
      padding: 8px;
      box-sizing: border-box;
      overflow-y: auto;
      height: 100%;
    }

    icon-block {
      margin: 2px;
    }
    icon-block::part(container) {
      padding: 4px;
    }

    icon-block:hover::part(container) {
      background-color: rgba(0, 0, 0, 0.05);
    }

    icon-block.selected::part(container) {
      background-color: rgba(14, 55, 205, 0.05);
    }
    .empty-con {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      min-height: 300px;
      font-size: 14px;
      color: #aaa;
      user-select: none;
    }
  </style>

  <x-fill :value="files">
    <icon-block
      :name="$data.name"
      :type="$data.type"
      on:dblclick="$host.gotoPath($data)"
      on:click="$host.select($event,$data)"
    ></icon-block>
  </x-fill>
  <x-if :value="!files.length">
    <div class="empty-con">Empty</div>
  </x-if>

  <script>
    export default async ({ load, query }) => {
      const { get } = await load("../../fs/main.js");
      const { confirm } = await load("@pui/dialog/command.js");

      const selfDir = await get(query.path);

      return {
        parent: "./frame.html",
        data: {
          paths: query.path ? query.path.split("/") : [],
          files: [],
        },
        proto: {
          async renameItem(name) {
            const selectedItem = this.shadow.$("icon-block.selected");
            selectedItem.renamemode = true;
          },
          async deleteItem(name) {
            const item = await selfDir.get(name);

            try {
              await item.remove();
            } catch (err) {
              const result = await confirm({
                title: `删除 ${item.name}`,
                content: "文件夹内包含其他文件，是否删除该文件夹？",
              });

              if (!result) {
                return;
              }

              await item.remove({ recursive: true });
            }
            this.reloadList();
          },
          async addFolder() {
            let name = "";

            let count = 1;
            while (true) {
              name = `newFolder${count}`;
              try {
                const target = await selfDir.get(name);
                count++;
              } catch (err) {
                break;
              }
            }
            await selfDir.get(name, {
              type: "directory",
              create: true,
            });

            await this.reloadList();
          },
          async reloadList() {
            const files = [];
            for await (let item of selfDir.values()) {
              files.push({
                type: item.kind,
                name: item.name,
                _item: item,
              });
            }

            this.files = files;
            this.parent.selectedName = "";
          },
          async gotoPath(data) {
            if (data.type === "directory") {
              this.app.goto(
                "@nos/apps/finder/files.html?path=" +
                  [...this.paths, data.name].join("/")
              );
              this.parent.selectedName = "";
            } else {
              console.log(await data._item.text());
            }
          },
          select(e, data) {
            e.stopPropagation();
            this.shadow.all("icon-block").forEach((block) => {
              if (data.name === block.name) {
                block.classList.add("selected");
                this.parent.selectedName = block.name;
              } else {
                block.classList.remove("selected");
              }
            });
          },
          clearSelect() {
            this.shadow.all("icon-block").forEach((block) => {
              block.classList.remove("selected");
            });
            this.parent.selectedName = "";
          },
        },
        ready() {
          this.reloadList();
          this.on("click", () => this.clearSelect());
          this.parent.paths = query.path ? query.path.split("/") : [];
          this.shadow.on("change-name", async (e) => {
            const { oldName, newName } = e.data;
            const handle = await selfDir.get(oldName);
            await handle.move(newName);
            this.reloadList();
          });
        },
      };
    };
  </script>
</template>
