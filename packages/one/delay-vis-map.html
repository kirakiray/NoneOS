<template component>
  <style>
    :host {
      display: block;
      padding: 16px;
    }

    #delayVisMap {
      width: 100%;
      min-height: 200px;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
    }
  </style>
  <div>
    <svg id="delayVisMap" xmlns="http://www.w3.org/2000/svg"></svg>
  </div>

  <script>
    export default async () => {
      return {
        tag: "n-delay-vis-map",
        data: {
          delays: [
            { time: 1762784162213, delay: 35 },
            { time: 1762784153180, delay: 37 },
            { time: 1762784117181, delay: 37 },
            { time: 1762784107179, delay: 36 },
            { time: 1762784097178, delay: 37 },
            { time: 1762784087180, delay: 37 },
            { time: 1762784077182, delay: 39 },
            { time: 1762784067181, delay: 37 },
            { time: 1762784056626, delay: 40 },
            { time: 1762784046627, delay: 42 },
          ],
        },
        watch: {
          delays() {
            this.drawChart();
          },
        },
        attached() {},
        proto: {
          drawChart() {
            const svg = this.shadow.$("#delayVisMap").ele;

            // 清除SVG内容
            svg.innerHTML = "";

            // 设置SVG大小
            const displayWidth = svg.clientWidth || 400;
            const displayHeight = svg.clientHeight || 200;

            svg.setAttribute("width", displayWidth);
            svg.setAttribute("height", displayHeight);

            // 获取数据
            const delays = this.delays;
            if (!delays || delays.length === 0) return;

            // 设置动态Y轴范围
            const minDelay = 0;
            const maxDataDelay = Math.max(...delays.map((d) => d.delay));
            
            // 根据数据最大值动态设置Y轴最大值
            let maxDelay;
            if (maxDataDelay <= 200) {
              maxDelay = 200;
            } else if (maxDataDelay <= 500) {
              maxDelay = 500;
            } else if (maxDataDelay <= 1000) {
              maxDelay = 1000;
            } else if (maxDataDelay <= 2000) {
              maxDelay = 2000;
            } else if (maxDataDelay <= 3000) {
              maxDelay = 3000;
            } else if (maxDataDelay <= 5000) {
              maxDelay = 5000;
            } else {
              maxDelay = 8000;
            }
            
            const range = maxDelay - minDelay;

            // 计算时间范围
            const times = delays.map((d) => d.time);
            const minTime = Math.min(...times);
            const maxTime = Math.max(...times);
            const timeRange = maxTime - minTime || 1; // 防止除零

            // 设置边距（为轴标签留出空间）
            const margin = { top: 20, right: 20, bottom: 40, left: 50 };
            const width = displayWidth - margin.left - margin.right;
            const height = displayHeight - margin.top - margin.bottom;

            // 添加辅助线
            const gridLines = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "g"
            );
            gridLines.setAttribute("stroke", "#f0f0f0");
            gridLines.setAttribute("stroke-width", "1");
            gridLines.setAttribute("opacity", "0.5");

            // 水平辅助线（Y轴）
            const yTicks = 5;
            for (let i = 0; i <= yTicks; i++) {
              const y = margin.top + height - (i * height) / yTicks;
              const line = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              line.setAttribute("x1", margin.left);
              line.setAttribute("y1", y);
              line.setAttribute("x2", margin.left + width);
              line.setAttribute("y2", y);
              gridLines.appendChild(line);
            }

            // 垂直辅助线（X轴）
            const xTicks = 5;
            for (let i = 0; i <= xTicks; i++) {
              const x = margin.left + (i * width) / xTicks;
              const line = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "line"
              );
              line.setAttribute("x1", x);
              line.setAttribute("y1", margin.top);
              line.setAttribute("x2", x);
              line.setAttribute("y2", margin.top + height);
              gridLines.appendChild(line);
            }

            svg.appendChild(gridLines);

            // 创建折线路径
            let pathData = "";
            const points = delays.map((point, index) => {
              const x =
                margin.left + ((point.time - minTime) / timeRange) * width;
              const y =
                margin.top +
                height -
                ((point.delay - minDelay) / range) * height;
              return { x, y };
            });

            // 构建路径数据
            points.forEach((point, index) => {
              if (index === 0) {
                pathData += `M ${point.x} ${point.y} `;
              } else {
                pathData += `L ${point.x} ${point.y} `;
              }
            });

            // 添加折线
            const path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            path.setAttribute("d", pathData);
            path.setAttribute("fill", "none");
            path.setAttribute("stroke", "#4285f4");
            path.setAttribute("stroke-width", "2");
            svg.appendChild(path);

            // 添加数据点
            points.forEach((point) => {
              const circle = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "circle"
              );
              circle.setAttribute("cx", point.x);
              circle.setAttribute("cy", point.y);
              circle.setAttribute("r", "3");
              circle.setAttribute("fill", "#4285f4");
              svg.appendChild(circle);
            });

            // 添加轴标签
            // Y轴标签
            const yAxisLabel = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            yAxisLabel.textContent = "delay";
            yAxisLabel.setAttribute("x", 10);
            yAxisLabel.setAttribute("y", margin.top + height / 2);
            yAxisLabel.setAttribute("text-anchor", "middle");
            yAxisLabel.setAttribute("font-family", "Arial");
            yAxisLabel.setAttribute("font-size", "12");
            yAxisLabel.setAttribute("fill", "#333");
            yAxisLabel.setAttribute(
              "transform",
              `rotate(-90, 10, ${margin.top + height / 2})`
            );
            svg.appendChild(yAxisLabel);

            // X轴标签
            const xAxisLabel = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "text"
            );
            xAxisLabel.textContent = "time";
            xAxisLabel.setAttribute("x", margin.left + width / 2);
            xAxisLabel.setAttribute("y", displayHeight - 10);
            xAxisLabel.setAttribute("text-anchor", "middle");
            xAxisLabel.setAttribute("font-family", "Arial");
            xAxisLabel.setAttribute("font-size", "12");
            xAxisLabel.setAttribute("fill", "#333");
            svg.appendChild(xAxisLabel);
          },
        },
      };
    };
  </script>
</template>
