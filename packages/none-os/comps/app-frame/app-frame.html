<template component>
  <link rel="stylesheet" href="../../public.css" />
  <l-m src="/packages/local-svg/local-svg.html"></l-m>
  <style>
    :host {
      position: absolute;
    }

    .container {
      display: flex;
      flex-direction: column;
      width: 100%;
      height: 100%;
    }

    .app-top {
      display: flex;
      user-select: none;
      height: 36px;
    }

    .top-main {
      display: flex;
      justify-content: center;
      align-items: center;
      flex: 1;
      font-size: 15px;
    }

    .top-btn {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 36px;
      height: 36px;
      cursor: pointer;
    }

    .top-btn:hover {
      background-color: var(--md-ref-palette-translucent-normal60);
    }
    .app-main {
      position: relative;
      flex: 1;
    }
    ::slotted(*) {
      display: block;
      width: 100%;
      height: 100%;
    }

    :host(.in-anime) {
      transition: all ease 0.2s;
    }
  </style>
  <div class="container frosted-glass">
    <div class="app-top">
      <div class="top-main">
        <div class="title">我是标题</div>
      </div>
      <div class="top-btn">
        <n-local-svg name="min"></n-local-svg>
      </div>
      <div class="top-btn">
        <n-local-svg name="multi"></n-local-svg>
      </div>
      <div class="top-btn">
        <n-local-svg name="max"></n-local-svg>
      </div>
      <div class="top-btn">
        <n-local-svg name="close"></n-local-svg>
      </div>
    </div>
    <div class="app-main">
      <slot></slot>
    </div>
  </div>
  <script>
    export default {
      tag: "n-app-frame",
      data: {
        appTop: 0,
        appLeft: 0,
        appWidth: 300,
        appHeight: 300,
      },
      watch: {
        ["appTop,appLeft,appWidth,appHeight"]([top, left, width, height]) {
          Object.assign(this.style, {
            top: `${top}px`,
            left: `${left}px`,
            width: `${width}px`,
            height: `${height}px`,
          });
        },
      },
      attached() {
        const topEle = this.shadow.$(".app-top");

        // 设置初始值
        const rect = this.parent.ele.getBoundingClientRect();

        Object.assign(this, {
          appTop: rect.height * 0.25,
          appLeft: rect.width * 0.25,
          appWidth: rect.width * 0.5,
          appHeight: rect.height * 0.5,
        });

        let startX, startY;
        let moveFunc, upFunc, leaveFunc;

        {
          // 拖动逻辑
          topEle.on("mousedown", (e) => {
            startX = e.clientX;
            startY = e.clientY;

            const { appTop, appLeft } = this;

            const parentRect = this.parent.ele.getBoundingClientRect();
            const selfRect = this.ele.getBoundingClientRect();

            const clearBind = (e) => {
              const { clientX, clientY } = e;

              const diffX = clientX - startX;
              const diffY = clientY - startY;

              let newAppTop = appTop + diffY;
              let newAppLeft = appLeft + diffX;

              let needAnime = false; // 主动修正定位时，需要添加动画

              if (newAppTop < -20) {
                newAppTop = 0;
                needAnime = 1;
              } else if (newAppTop > parentRect.height - 80) {
                newAppTop = parentRect.height - 80;
                needAnime = 1;
              }

              if (newAppLeft + 80 > parentRect.width) {
                newAppLeft = parentRect.width - 80;
                needAnime = 1;
              } else if (newAppLeft + selfRect.width < 120) {
                newAppLeft = -1 * selfRect.width + 120;
                needAnime = 1;
              }

              if (needAnime) {
                this.classList.add("in-anime");

                setTimeout(() => {
                  this.classList.remove("in-anime");
                }, 300);
              }

              Object.assign(this, {
                appLeft: newAppLeft,
                appTop: newAppTop,
              });

              $("body").off("mousemove", moveFunc);
              $("body").off("mouseup", upFunc);
              $("body").off("mouseleave", leaveFunc);
            };

            $("body").on(
              "mousemove",
              (moveFunc = (e) => {
                const { clientX, clientY } = e;

                const diffX = clientX - startX;
                const diffY = clientY - startY;

                Object.assign(this.style, {
                  left: appLeft + diffX + "px",
                  top: appTop + diffY + "px",
                });
              })
            );

            $("body").on(
              "mouseup",
              (upFunc = (e) => {
                const { clientX, clientY } = e;

                clearBind(e);
              })
            );

            $("body").on(
              "mouseleave",
              (leaveFunc = (e) => {
                clearBind(e);
              })
            );
          });
        }
      },
    };
  </script>
</template>
