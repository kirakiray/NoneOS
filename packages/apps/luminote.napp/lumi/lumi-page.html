<template component>
  <l-m src="./lumi-block.html"></l-m>
  <link rel="stylesheet" href="/packages/none-os/public.css" />
  <style>
    :host {
      display: block;
      margin: 0 auto;
      user-select: auto;
    }
    /* .container {
    } */

    .title {
      font-size: 40px;
      font-weight: 700;
      box-sizing: border-box;
      margin: 0 6px;
      width: 100%;
      outline: none;
      background-color: transparent;
      -webkit-appearance: none;
      appearance: none;
      border: none;
      color: inherit;
    }
  </style>
  <o-if :value="itemData.removed">
    <div
      style="
        display: flex;
        background-color: var(--md-sys-color-on-error);
        color: var(--md-sys-color-error);
        padding: 8px 16px;
        border-radius: 6px;
      "
    >
      此文章已暂时被放到回收站

      <p-button
        size="small"
        color="primary"
        variant="outlined"
        on:click="itemData.removed = null"
        style="margin-left: auto"
      >
        放回原处
      </p-button>
    </div>
  </o-if>
  <div
    class="container"
    on:multi-select-component="multiSelectComponent"
    on:multi-snap-select-component="multiSnapSelectComponent"
    on:block-copy="handleBlockCopy"
    on:block-delete="handleBlockDelete"
    on:block-undo="handleBlockUndo"
    on:block-merge-prev="handleMergePrev"
  >
    <div style="height: 100px"></div>
    <div style="margin: 0 auto; max-width: 800px; width: 100%">
      <input
        id="title"
        class="title"
        type="text"
        sync:value="itemData.title"
        on:click="$event.stopPropagation()"
        style="margin-bottom: 16px"
        on:keydown="titleKeyDown"
        placeholder="页面标题"
      />
    </div>
    <slot></slot>
  </div>

  <style>
    .mask {
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      z-index: 10000;
      pointer-events: none;
    }

    .mask.show-multi-panel {
      pointer-events: auto;
    }

    .multi-panel {
      position: fixed;
      top: 100px;
      left: 100px;
      padding: 3px;
      background-color: var(--md-sys-color-on-normal);
      box-shadow: var(--contained-shadow);
      border-radius: 20px;
      opacity: 0;
      transform: translateX(10px);
      transition: opacity ease 0.2s, transform ease 0.2s;
      white-space: nowrap;
    }

    .mask.show-multi-panel .multi-panel {
      opacity: 1;
      transform: translateX(0);
    }
  </style>

  <div
    class="mask"
    class:show-multi-panel="multiSelected"
    on:click="clickMultiMask"
  >
    <div
      class="multi-panel"
      :style.top="multiPanelStyle.top"
      :style.left="multiPanelStyle.left"
    >
      <p-button size="small" variant="text" on:click="clickMultiCopy">
        <n-local-icon
          name="copy"
          slot="prefix"
          style="display: block; margin-right: 4px"
        ></n-local-icon>
        复制
      </p-button>
      <p-button
        size="small"
        color="error"
        variant="text"
        on:click="clickMultiDelete"
      >
        <n-local-icon
          name="delete"
          slot="prefix"
          style="display: block; margin-right: 4px"
        ></n-local-icon>
        删除
      </p-button>
    </div>
  </div>
  <script>
    let selfUserId;
    export default async ({ load }) => {
      const { diffFill } = await load("./util/diff-fill.js");
      const { toast } = await load("/packages/pui/util.js");
      const {
        letterDataToElement,
        elementToLetterData,
        getSelectionLetterData,
      } = await load("./util/range.js");

      const { saveHistory, handleUndo, clearUndoHistory } = await load(
        "./util/page-undo-util.js"
      );

      if (!selfUserId) {
        try {
          const { getUserStore } = await load("/packages/user/user-store.js");
          const userStore = await getUserStore();

          selfUserId = userStore.userId;
        } catch (err) {}
      }

      return {
        tag: "lumi-page",
        data: {
          itemData: {},
          multiSelected: false,
          multiPanelStyle: {
            top: 0,
            left: 0,
          },
        },
        proto: {
          async handleMergePrev(e) {
            const target = $(e.target);
            const targetIndex = this.itemData.content.indexOf(target.itemData);

            if (targetIndex > 0) {
              const prev = target.prev;
              // 和前一个数据合并
              const currentLetterData = await elementToLetterData(
                target.$("[inputer-content]").ele
              );
              const prevLetterData = await elementToLetterData(
                prev.$("[inputer-content]").ele
              );

              const newLetterData = [...prevLetterData, ...currentLetterData];
              const newContent = await letterDataToElement(newLetterData);

              // 更新前一个数据
              prev.itemData.value = newContent;

              // 删除当前的数据
              this.itemData.content.splice(targetIndex, 1);

              // 修复焦点
              setTimeout(() => {
                prev.focus(prevLetterData.length);
              }, 1);
            }
          },
          async handleBlockUndo(e) {
            await handleUndo(this);
          },
          handleBlockCopy(e) {
            e.stopPropagation();
            this.clickMultiCopy();
          },
          handleBlockDelete(e) {
            e.stopPropagation();
            this.clickMultiDelete();
            this.multiSelected = false;
          },
          clickMultiCopy() {
            let textContent = "";
            let htmlContent = "";

            const lastIndex = this._rangData.length - 1;

            this._rangeEl.forEach((item, index) => {
              textContent += item.text;
              if (index !== lastIndex) {
                textContent += `\n\n`;
              }

              htmlContent += item.htmlContent + "\n";
            });

            navigator.clipboard.write([
              new ClipboardItem({
                "text/html": new Blob([htmlContent], { type: "text/html" }),
                "text/plain": new Blob([textContent], { type: "text/plain" }),
              }),
            ]);

            toast("复制成功");
          },
          clickMultiDelete() {
            // 逐个删除内容
            const { content } = this.itemData;

            this._rangData.forEach((item) => {
              if (item.type === "article") {
                item.removed = true;
              } else {
                const index = content.indexOf(item);
                content.splice(index, 1);
              }
            });
          },
          clickMultiMask() {
            this.multiSelected = false;
            this.forEach((e) => {
              if (e.selected) {
                e.selected = false;
              }
            });
          },
          // 鼠标移动时的临时选中
          multiSnapSelectComponent(e) {
            const { data } = e;
            const { originEvent } = data;

            const start =
              data.startIndex > data.endIndex ? data.endIndex : data.startIndex;
            const end =
              data.startIndex > data.endIndex ? data.startIndex : data.endIndex;

            if (start === end) {
              this.forEach((e, i) => {
                e.selected = null;
              });
              return;
            }

            // 修正选中区域
            this.forEach((e, i) => {
              if (i >= start && i <= end) {
                e.selected = true;
              } else {
                e.selected = null;
              }
            });
          },
          // 多选选中组件
          multiSelectComponent(e) {
            e.stopPropagation();
            const { data } = e;
            const { originEvent } = data;

            const start =
              data.startIndex > data.endIndex ? data.endIndex : data.startIndex;
            const end =
              data.startIndex > data.endIndex ? data.startIndex : data.endIndex;

            const rangeData = this.itemData.content.slice(start, end + 1);
            const rangeEl = this.slice(start, end + 1);

            // 选中目标的组件，并弹窗显示操作
            rangeEl.forEach((e) => (e.selected = true));

            this._rangeEl = rangeEl;
            this._rangData = rangeData;

            if (!originEvent) {
              const rect = e.target.getBoundingClientRect();

              // 直接使用当前鼠标的坐标轴
              this.multiPanelStyle = {
                left: `${rect.left + rect.width / 2}px`,
                top: `${rect.top}px`,
              };
            } else {
              this.multiPanelStyle = {
                left: `${originEvent.clientX}px`,
                top: `${originEvent.clientY}px`,
              };

              // 如果超出了屏幕边, 改为靠右
              const width = parseInt(this.shadow.$(".multi-panel").css.width);

              const selfRect = this.ele.getBoundingClientRect();

              if (
                width + originEvent.clientX >
                selfRect.width + selfRect.left
              ) {
                this.multiPanelStyle.left =
                  selfRect.width - width + selfRect.left + "px";
              }
            }

            // 取消原来选中的范围
            window.getSelection().removeAllRanges();

            this.multiSelected = true;
          },
          titleKeyDown(e) {
            if (e.key === "Enter") {
              // 如果第一个元素不是空元素，则添加空元素后聚焦
              let firstBlock = this[0];

              if (!firstBlock.itemData.value.trim()) {
                firstBlock.focus();
                return;
              }

              this.itemData.content.unshift({
                type: "paragraph",
                value: "",
              });

              setTimeout(() => {
                this[0].focus();
              }, 10);
            }
          },
          focusTitle() {
            this.shadow.$(".title").ele.focus();
          },
          // focusLast() {
          //   setTimeout(() => {
          //     // this.shadow.$("#lumi-fill-el").slice(-1)[0].focus();
          //     this.slice(-1)[0].focus();
          //   }, 30);
          // },
          async handleEnter(data, index, originEvent) {
            const finnalIndex = index + 1;

            // 获取选中的焦点
            const selectionRangeData = await getSelectionLetterData(
              this.ele.getRootNode()
            );

            // 截取焦点后的内容
            const afterLetterData = selectionRangeData.letterData.slice(
              selectionRangeData.startOffset
            );

            if (afterLetterData.length) {
              const beforeLetterData = selectionRangeData.letterData.slice(
                0,
                selectionRangeData.startOffset
              );

              const beforeContent = await letterDataToElement(beforeLetterData);
              const afterContent = await letterDataToElement(afterLetterData);

              // 获取对应选中的组件
              const selectedComponent = this[index];

              // 更新回车后的内容
              selectedComponent.itemData.value = beforeContent;

              // 从焦点位置将内容带下去
              this.itemData.content.splice(finnalIndex, 0, {
                type: "paragraph",
                value: afterContent,
              });
            } else {
              // 最末尾添加
              this.itemData.content.splice(finnalIndex, 0, {
                type: "paragraph",
                value: "",
              });
            }

            setTimeout(() => {
              // this.shadow.$("#lumi-fill-el")[finnalIndex].focus();
              this[finnalIndex].focus("start");
            }, 1);
          },
          async handleDelete(data, index) {
            this.itemData.content.splice(index, 1);

            setTimeout(() => {
              let prevBlock = this[index - 1];

              while (prevBlock && prevBlock.data.type === "article") {
                prevBlock = prevBlock.prev;
              }

              // 文本焦点放在最后
              prevBlock && prevBlock.focus();
            }, 10);
          },
          handleDrop(data, index, event) {
            if (!event.data) {
              // 会触发两次
              return;
            }

            const { sourceData } = event.data;

            // 查看元数据是不是在content上，是的话相当于剪切
            const sourceIndex = this.itemData.content.indexOf(sourceData);

            if (sourceIndex !== -1) {
              this.itemData.content.splice(sourceIndex, 1);
            }

            const currentIndex = this.itemData.content.indexOf(data);

            this.itemData.content.splice(currentIndex + 1, 0, sourceData);
          },
        },
        attached() {
          // 先清空
          clearUndoHistory();

          this.on("click", async (e) => {
            // 最后面聚焦
            if (!this.itemData?.content?.length) {
              return;
            }

            // 判断最后一个是不是空白，不是的话加一个
            const lastItem = this.itemData.content.slice(-1)[0];
            if (lastItem.value !== "" || lastItem.type === "article") {
              this.itemData.content.push({
                type: "paragraph",
                value: "",
              });

              await new Promise((res) => setTimeout(res, 30));
            }

            if (this.length > 1) {
              const finnalItem = this[this.length - 1];
              finnalItem && finnalItem.focus && finnalItem.focus();
            }
          });

          {
            // BUG: safari无法获取shadow root 内的 selection
            this.watchTick((e) => {
              if (!e.hasModified("itemData")) {
                return;
              }

              const finalArr = Array.from(e).filter(
                (e) =>
                  e.name !== "dataStatus" &&
                  e.name !== "inFocus" &&
                  e.name !== "focusUser"
              );

              if (!finalArr.length) {
                return;
              }

              saveHistory(this, e);

              const { content } = this.itemData;

              if (!content) {
                return;
              }

              diffFill({
                container: this,
                data: content,
                create: ({ item }) => {
                  const blockEl = $(`<lumi-block></lumi-block>`);

                  blockEl.itemData = item;

                  return blockEl;
                },
                isEqual: (subEl, item) => {
                  return subEl.itemData === item;
                },
              });
            });

            this.on("enter", (e) => {
              e.stopPropagation();
              const lumiblock = $(e.target);

              this.handleEnter(
                lumiblock.itemData,
                lumiblock.index,
                e.data.originEvent
              );
            });
            this.on("delete", (e) => {
              e.stopPropagation();
              const lumiblock = $(e.target);

              this.handleDelete(lumiblock.itemData, lumiblock.index);
            });
            this.on("drop", (e) => {
              e.stopPropagation();

              const lumiblock = $(e.target);
              this.handleDrop(lumiblock.itemData, lumiblock.index, e);
            });

            document.addEventListener(
              "keydown",
              (this._keydownFunc = (e) => {
                if (e.key === "z" && (e.ctrlKey || e.metaKey)) {
                  console.log(e.target, e.composedPath());
                  // 属于编辑器或body的操作
                  if (
                    e
                      .composedPath()
                      .filter((e) => e.matches && e.matches("lumi-block"))
                      .length ||
                    e.target === document.body
                  ) {
                    const [app] = this.parents.filter((e) => e.tag === "o-app");
                    e.preventDefault();

                    if (app.focused()) {
                      // 属于自身聚焦的状态，才允许撤销
                      this.handleBlockUndo();
                    }
                  }
                }
              })
            );
          }
        },
        detached() {
          this.itemData = {}; // 清除绑定
          document.removeEventListener("keydown", this._keydownFunc);
        },
      };
    };
  </script>
</template>
