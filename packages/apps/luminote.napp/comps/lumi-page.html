<template component>
  <l-m src="./lumi-block.html"></l-m>
  <style>
    :host {
      display: block;
      margin: 0 auto;
    }
    .container {
    }

    .title {
      font-size: 40px;
      font-weight: 700;
      margin: 0 6px;
      outline: none;
      background-color: transparent;
      -webkit-appearance: none;
      appearance: none;
      border: none;
      color: inherit;
    }
  </style>
  <div class="container">
    <div style="height: 100px"></div>
    <div style="margin: 0 auto; max-width: 800px; width: 100%">
      <input
        id="title"
        class="title"
        type="text"
        sync:value="itemData.title"
        on:click="$event.stopPropagation()"
        style="margin-bottom: 16px"
        on:keydown="titleKeyDown"
        placeholder="页面标题"
      />
    </div>
    <div id="lumi-fill-el">
      <o-fill :value="itemData.content" fill-key="_dataId">
        <lumi-block
          :item-data="$data"
          on:enter="$host.handleEnter($data,$index)"
          on:delete="$host.handleDelete($data,$index)"
          on:drop="$host.handleDrop($data,$index,$event)"
        ></lumi-block>

        <!-- <div
          :item-data="$data"
          on:enter="$host.handleEnter($data,$index)"
          on:delete="$host.handleDelete($data,$index)"
          on:drop="$host.handleDrop($data,$index,$event)"
        >
          {{$data.type}} - {{$data.value}}
        </div> -->
      </o-fill>
    </div>
  </div>
  <script>
    export default async () => {
      return {
        tag: "lumi-page",
        data: {
          itemData: {},
        },
        proto: {
          titleKeyDown(e) {
            if (e.key === "Enter") {
              this.focusLast();
            }
          },
          focusTitle() {
            focusAndSetCursorAtEnd(this.shadow.$(".title").ele);
          },
          focusLast() {
            setTimeout(() => {
              focusAndSetCursorAtEnd(
                this.shadow.$("#lumi-fill-el").slice(-1)[0].editorElement
              );
            }, 30);
          },
          async handleEnter(data, index) {
            const finnalIndex = index + 1;

            this.itemData.content.splice(finnalIndex, 0, {
              type: "paragraph",
              value: "",
            });

            setTimeout(() => {
              this.shadow.$("#lumi-fill-el")[finnalIndex].focus();
            }, 1);
          },
          async handleDelete(data, index) {
            this.itemData.content.splice(index, 1);

            setTimeout(() => {
              const fillEl = this.shadow.$("#lumi-fill-el");

              // 获取对上的一个元素
              const prevBlock = fillEl[index - 1];

              // 文本焦点放在最后
              focusAndSetCursorAtEnd(prevBlock.editorElement);
            }, 1);
          },
          handleDrop(data, index, event) {
            if (!event.data) {
              // 会触发两次
              return;
            }

            const { sourceData } = event.data;

            // 查看元数据是不是在content上，是的话相当于剪切
            const sourceIndex = this.itemData.content.indexOf(sourceData);

            if (sourceIndex !== -1) {
              this.itemData.content.splice(sourceIndex, 1);
            }

            const currentIndex = this.itemData.content.indexOf(data);

            this.itemData.content.splice(currentIndex + 1, 0, sourceData);
          },
        },
        attached() {
          this.on("click", async (e) => {
            // 最后面聚焦
            const fillEl = this.shadow.$("#lumi-fill-el");

            // 判断最后一个是不是空白，不是的话加一个
            const lastItem = this.itemData.content.slice(-1)[0];
            if (lastItem.value !== "" || lastItem.type === "article") {
              this.itemData.content.push({
                type: "paragraph",
                value: "",
              });

              await new Promise((res) => setTimeout(res, 30));
            }

            if (fillEl.length > 1) {
              focusAndSetCursorAtEnd(fillEl[fillEl.length - 1].editorElement);
            }
          });
        },
        detached() {
          this.itemData = {}; // 清除绑定
        },
      };
    };

    function focusAndSetCursorAtEnd(element) {
      if (!element) {
        return;
      }

      element.focus();
      const range = document.createRange();
      const selection = window.getSelection();

      range.selectNodeContents(element);
      range.collapse(false);

      selection.removeAllRanges();
      selection.addRange(range);
    }
  </script>
</template>
