<template component>
  <l-m src="./lumi-block.html"></l-m>
  <style>
    :host {
      display: block;
      margin: 0 auto;
      /* background-color: rgba(0, 128, 0, 0.3); */
    }
    .container {
      display: flex;
      flex-direction: column;
    }
  </style>
  <div class="container">
    <div style="height: 100px"></div>
    <o-fill id="lumi-fill-el" :value="contents">
      <lumi-block
        sync:type="$data.type"
        sync:value="$data.value"
        on:enter="$host.handleEnter($data,$index)"
        on:delete="$host.handleDelete($data,$index)"
        on:drop="$host.handleDrop($data,$index,$event)"
      ></lumi-block>
    </o-fill>
  </div>
  <script>
    export default async () => {
      return {
        tag: "lumi-page",
        data: {
          contents: [
            {
              type: "h1",
              value: "基本的文本编辑功能：加粗、斜体、下划线和插入图片",
            },
            {
              type: "paragraph",
              value:
                "您可以通过继承 TextEditor 类来扩展这个编辑器的功能，或者直接使用它作为一个简单的富文本编辑器。",
            },
            {
              type: "paragraph",
              value:
                "如果您需要添加更多功能，比如字体大小、颜色选择、列表等，可以在工具栏中添加相应的按钮，并在 handleToolbarAction 方法中实现相应的功能。",
            },
            {
              type: "paragraph",
              value: "",
            },
          ],
        },
        proto: {
          async handleEnter(data, index) {
            const insData = $.stanz({
              type: "paragraph",
              value: "",
            });

            const finnalIndex = index + 1;

            this.contents.splice(finnalIndex, 0, insData);

            setTimeout(() => {
              this.shadow.$("#lumi-fill-el")[finnalIndex].focus();
            }, 1);
          },
          async handleDelete(data, index) {
            this.contents.splice(index, 1);

            setTimeout(() => {
              const fillEl = this.shadow.$("#lumi-fill-el");

              // 获取对上的一个元素
              const prevBlock = fillEl[index - 1];

              // 文本焦点放在最后
              focusAndSetCursorAtEnd(prevBlock.editorElement);
            }, 1);
          },
          handleDrop(data, index, event) {
            if (!event.data) {
              // 会触发两次
              return;
            }

            const { sourceData } = event.data;

            // 查看元数据是不是在contents上，是的话相当于剪切
            const sourceIndex = this.contents.indexOf(sourceData);

            if (sourceIndex !== -1) {
              this.contents.splice(sourceIndex, 1);
            }

            const currentIndex = this.contents.indexOf(data);

            this.contents.splice(currentIndex + 1, 0, sourceData);
          },
        },
        attached() {
          this.contents.watchTick(() => {
            console.log("contents: ", this.contents.toJSON());
          });

          this.on("click", (e) => {
            // 最后面聚焦
            const fillEl = this.shadow.$("#lumi-fill-el");

            if (fillEl.length > 1) {
              fillEl[fillEl.length - 1].focus();
            }
          });
        },
      };
    };

    function focusAndSetCursorAtEnd(element) {
      element.focus();
      const range = document.createRange();
      const selection = window.getSelection();

      range.selectNodeContents(element);
      range.collapse(false);

      selection.removeAllRanges();
      selection.addRange(range);
    }
  </script>
</template>
