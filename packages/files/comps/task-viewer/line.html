<template component>
  <style>
    :host {
      display: block;
      margin: 4px 0;
      padding: 4px;
      border: #aaa solid 1px;
      border-radius: 4px;
    }
    .pathname {
      word-break: break-all;
      font-size: 12px;
      font-weight: bold;
      line-height: 1.2em;
    }

    .blocks {
      display: flex;
      flex-wrap: wrap;
      margin-top: 4px;
    }

    .block {
      width: 10px;
      height: 10px;
      margin: 1px;
      border-radius: 2px;
      border: var(--md-sys-color-on-normal-container) solid 1px;
    }

    .block.actived {
      background-color: var(--md-sys-color-primary);
      border-color: var(--md-sys-color-primary);
    }
  </style>
  <div class="pathname">{{filedata.path}} ({{percentTage}}%)</div>
  <div class="blocks"></div>
  <script>
    export default async ({ load }) => {
      const { get } = await load("/packages/fs/main.js");
      const { on, copyTo } = await load("/packages/fs/task.js");

      return {
        tag: "task-viewer-line",
        data: {
          // 主体的文件信息
          filedata: {
            hashs: [],
            path: "",
            size: "",
          },
          cachepath: "", // 缓存文件所在的目录
          cached: 0, // 已经缓存的个数
          total: 0, // 一共多少个
        },
        proto: {
          get percentTage() {
            return Math.ceil((this.cached / this.total) * 100);
          },
          // 修正缓存中的文件进度
          async checkCached() {
            const cacheDir = await get(this.cachepath);

            this.cached = 0;

            await Promise.all(
              this.filedata.hashs.map(async (hash) => {
                const handle = await cacheDir.get(hash);

                if (handle) {
                  const size = await handle.size();

                  if (size) {
                    // 设置缓存成功
                    const blockEl = this.shadow.$(
                      `.block[data-hash="${hash}"]`
                    );

                    if (blockEl) {
                      this.cached++;
                      blockEl.classList.add("actived");
                    }
                  }
                }
              })
            );
          },
        },
        watch: {
          filedata(data) {
            // 由于生成块可能会非常多，所以不采用渲染模板，而是直接生成dom
            const blocksEl = this.shadow.$(".blocks");

            data.hashs.forEach((hash) => {
              blocksEl.push(
                `<div class="block" data-hash="${hash}" title="${hash}"></div>`
              );
            });

            this.total = this.filedata.hashs.length;

            this.checkCached();
          },
        },
        attached() {
          this._cancels = [
            on("writed", (e) => {
              const { data } = e;

              const targets = this.shadow.all(`[data-hash="${data.hash}"]`);

              targets.forEach((e) => {
                e.classList.add("actived");
              });

              if (targets.length && !data.exited) {
                this.cached++;
              }

              if (this.cachepath === data.cachePath) {
              }
            }),
          ];
        },
        detached() {
          if (this._cancels) {
            this._cancels.forEach((f) => f());
            this._cancels.length = 0;
          }
        },
      };
    };
  </script>
</template>
