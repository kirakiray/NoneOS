!function(){"use strict";const e={pathEmpty:"文件路径不能为空",indexErr:"在数据库{dbname}的{storename}表中没有找到索引{key}",setDataErr:"设置数据出错",findDataErr:"查找数据出错",getDataErr:"获取数据出错",rootEmpty:"不允许使用 '/' 开头的路径",rootNotExist:"根目录 {rootname} 不存在",pathNotFound:"未找到文件夹:{path}",storeNotExistMethod:"store中不存在方法 {method}",invalidCreateType:"create必须等于'file'或'dir'",notDeleteRoot:"不能直接删除根节点{name}",deleted:"当前handle已被删除，不能使用{name}；旧地址为:{path}",exitedName:"操作失败，{name}已经存在",tolowcase:"文件系统对大小写不敏感，{oldName}将会被转为{newName}",writefile:"写入文件内容失败:{path}",noPicker:"当前浏览器不支持文件选择",targetAnotherType:"{path} 已经是一个'{exitedType}'，不能创建为'{targetType}'",notMoveToChild:"{targetPath} 是 {path} 的子目录，不能移动到自己的子目录",notFoundChunk:"{path}文件没有找到对应的块文件:{hash}",pathInvalid:"路径不能包含特殊字符 {path}"},t=(t,a,r)=>{let n,s=e[t];if(a)for(let e in a)s=s.replace(new RegExp(`{${e}}`,"g"),a[e]);return n=r?new Error(s,{cause:r}):new Error(s),n.code=t,n},a={};function r(e=10){const t=new Uint8Array(e);return crypto.getRandomValues(t),Array.from(t,(e=>("0"+e.toString(32)).slice(-2))).join("")}const n=async(e="noneos_fs_defaults")=>(a[e]||(a[e]=new Promise((t=>{const r=indexedDB.open(e);r.onsuccess=async r=>{const n=r.target.result;n.onclose=()=>{a[e]=null},t(n)},r.onupgradeneeded=e=>{const t=e.target.result,a=t.createObjectStore("main",{keyPath:"key"});a.createIndex("parent","parent",{unique:!1}),a.createIndex("parent_and_name",["parent","name"],{unique:!0}),a.createIndex("hash","hash",{unique:!1}),t.createObjectStore("blocks",{keyPath:"hash"})},r.onerror=t=>{throw new Event(e+" creation error",{cause:t.error})}}))),a[e]),s=async({dbname:e="noneos_fs_defaults",storename:a="main",index:r,all:s=!1,method:i="get",key:o})=>{let c=await(async({storename:e,index:a,dbname:r})=>{let s=(await n(r)).transaction([e],"readonly").objectStore(e);if(a)try{s=s.index(a)}catch(n){throw t("indexErr",{dbname:r,storename:e,key:a},n)}return s})({storename:a,index:r,dbname:e});if(!c[i])throw t("storeNotExistMethod",{method:i});return new Promise(((e,a)=>{c=c[i](o),c.onsuccess=t=>{e(t.target.result)},c.onerror=e=>{a(t("getDataErr",null,e.target.error))}}))},i=new Map,o=async({dbname:e="noneos_fs_defaults",storename:a="main",datas:r,removes:s})=>{if(!r?.length&&!s?.length)return!0;const o=await n(e);return new Promise(((e,n)=>{const c=o.transaction([a],"readwrite");c.oncomplete=t=>{r&&r.forEach((e=>{e.parent&&i.delete(`${e.parent}-${e.name}`)})),e(!0)},c.onerror=e=>{n(t("setDataErr",null,e.target.error))};const h=c.objectStore(a);r&&r.forEach((e=>{if(e.parent){const t=i.get(`${e.parent}-${e.name}`);if(t){const a=t;Object.assign(e,a)}else i.set(`${e.parent}-${e.name}`,e)}h.put(e)})),s&&s.length&&s.forEach((e=>h.delete(e)))}))},c=async e=>{const t=[];await Promise.all(e.map((async e=>{!await s({index:"hash",key:e})&&t.push(e)}))),t.length&&await o({storename:"blocks",removes:t})},h=async(e,a)=>{const r=await s({key:e.id});if(!r)throw t("deleted",{name:a,path:e.path},e);return r},l=async e=>{const t=[],a=Date.now();let r=e;for(;r;){const e=await s({key:r});if(!e)break;e.lastModified=a,t.push(e),r=e.parent}await o({datas:t})},u=async({source:e,target:t,name:a,callback:r})=>{if([t,a]=await p({target:t,name:a,self:e}),"file"===e.kind){const n=await e.file(),s=await t.get(a,{create:"file"});return await s.write(n,r),s}if("dir"===e.kind){const n=await t.get(a,{create:"dir"});return await e.forEach((async e=>{await u({source:e,target:n,name:e.name,callback:r})})),n}},p=async({target:e,name:a,self:r})=>{"string"==typeof e&&(a=e,e=await r.parent()),a||(a=r.name);let n=!1;for await(let t of e.keys())if(a===t){n=1;break}if(n)throw t("exitedName",{name:`${a}(${e.path}/${a})`});if(function(e,t){if(e===t)return!1;const a=t.split("/").filter((e=>e.length)),r=e.split("/").filter((e=>e.length));return a.every(((e,t)=>r[t]===e))}(e.path,r.path))throw t("notMoveToChild",{targetPath:e.path,path:r.path});return[e,a]};const d=async e=>{if("file"===e.kind)return[await f(e)];const t=[];for await(let a of e.values())if("dir"===a.kind){const e=await d(a);t.push(...e)}else t.push(await f(a));return t},f=async e=>{const t={size:await e.size(),path:e.path};return Object.defineProperty(t,"handle",{get:()=>e}),t},w=1048576,m=e=>{const t=e.reduce(((e,t)=>e+t.byteLength),0),a=new Uint8Array(t);let r=0;return e.forEach((e=>{a.set(new Uint8Array(e),r),r+=e.byteLength})),a},y=async e=>{if("string"==typeof e){e=(new TextEncoder).encode(e)}const t=await crypto.subtle.digest("SHA-256",e);return Array.from(new Uint8Array(t)).map((e=>e.toString(16).padStart(2,"0"))).join("")},g=/[<>:"\\|?*\x00-\x1F]/;const b=Symbol("storage-name"),k=Symbol("idb");class v{constructor(e="public"){return this[b]="main",this[k]=new Promise((t=>{let a=indexedDB.open(`ever-cache-${e}`);a.onsuccess=e=>{t(e.target.result)},a.onupgradeneeded=e=>{e.target.result.createObjectStore("main",{keyPath:"key"})}})),new Proxy(this,E)}async setItem(e,t){return T(this,(a=>a.put({key:e,value:t}))).then((()=>!0))}async getItem(e){try{return T(this,(t=>t.get(e)),"readonly").then((e=>{const{result:t}=e.target;return t?t.value:null}))}catch(e){}}async removeItem(e){return T(this,(t=>t.delete(e))).then((()=>!0))}async clear(){return T(this,(e=>e.clear())).then((()=>!0))}async key(e){return T(this,(e=>e.getAllKeys())).then((t=>t.target.result[e]))}get length(){return T(this,(e=>e.count())).then((e=>e.target.result))}entries(){return{[Symbol.asyncIterator]:()=>{let e,t;const a=()=>{t=new Promise((t=>e=t))};return a(),T(this,(e=>e.openCursor()),"readonly",(t=>e(t.target.result))),{async next(){const e=await t;if(!e)return{done:!0};a();const{key:r,value:n}=e.value;return e.continue(),{value:[r,n],done:!1}}}}}}async*keys(){for await(let[e,t]of this.entries())yield e}async*values(){for await(let[e,t]of this.entries())yield t}}const x=new Set(Object.getOwnPropertyNames(v.prototype)),E={get:(e,t,a)=>x.has(t)||"symbol"==typeof t?Reflect.get(e,t,a):e.getItem(t),set:(e,t,a)=>e.setItem(t,a),deleteProperty:(e,t)=>e.removeItem(t)},T=async(e,t,a="readwrite",r)=>{const n=await e[k];return new Promise(((s,i)=>{const o=t(n.transaction([e[b]],a).objectStore(e[b]));o.onsuccess=e=>{if(r){const t=r(e);t&&s(t)}else s(e)},o.onerror=e=>{i(e)}}))};new v,$.stanz([]);const j=$.stanz([]);new EventTarget;const D=$.stanz([]),I={},P={};D.watchTick((()=>{D.length>100&&D.splice(70)}),100);const A=new v("noneos-blocks-data");let _=null;const C=async()=>{const e=[];try{for await(let[t,a]of A.entries()){Date.now()-a.time>6e5&&e.push(t)}const t=await W("local/caches/blocks");e.length&&await Promise.all(e.map((async e=>{await A.removeItem(e);const a=await t.get(e);a&&await a.remove()}))),console.log("clear cache: ",e.length)}catch(e){console.error(e)}return clearTimeout(_),_=setTimeout((()=>C()),6e4),e};C();const M=async({data:e,path:t,reason:a,userId:r})=>{const n=await(async(e,t=1048576)=>{let a;if("string"==typeof e)a=(new TextEncoder).encode(e).buffer;else if(e instanceof Blob)a=await e.arrayBuffer();else if(e instanceof ArrayBuffer)a=e;else{if(!(e instanceof Uint8Array))throw new Error("Input must be a string, File object or ArrayBuffer object");a=e.buffer}const r=[];for(let e=0;e<a.byteLength;e+=t){const n=a.slice(e,e+t);r.push(n)}return r})(e,131072);return await N(n,{reason:a,reasonData:{path:t,userId:r}})},N=async(e,{reason:t,reasonData:a})=>{const r=await W("local/caches/blocks",{create:"dir"}),n=await Promise.all(e.map((async e=>{const t=await y(e);A.setItem(t,{time:Date.now()});const a=await r.get(t,{create:"file"});return await a.write(e),P[t]&&P[t].resolve(e),t})));return D.unshift({type:"save",hashs:n,time:Date.now(),reason:t,reasonData:a}),n},L=async(e,{reason:t,reasonData:a})=>{const r=await W("local/caches/blocks",{create:"dir"}),n=[],s=await Promise.all(e.map((async e=>{const t=await r.get(e);return t?(n.push(e),{hash:e,data:await t.buffer()}):{hash:e}})));return D.unshift({type:"get",hashs:e,time:Date.now(),reasonData:{exists:n,...a},reason:t}),s};class S{constructor(){}async flat(){return d(this)}async _saveCache({options:e}){const t=await this.buffer(e);return await M({data:t,reason:"save-cache",path:this.path,userId:this.__remote_user})}async _writeByCache({hashs:e,userId:t}){const a=await(async({hashs:e,userId:t,reason:a,path:r})=>{let n;t&&(n=j.find((e=>e.userId===t)));const s={path:r};n&&(s.userId=n.userId);const i=await L(e,{reason:a,reasonData:s}),o=[];i.forEach((e=>{e.data||o.push(e.hash)})),o.length&&n.send({type:"get-block",path:r,hashs:o});const c=await Promise.all(i.map((async e=>{const{hash:t,data:a}=e;if(a)return a;let r=I[t];return r||(r=I[t]=new Promise(((e,a)=>{let r=()=>{r=null,delete I[t],delete P[t]};P[t]={resolve(t){e(t),r()},reject(e){a(e),r()}}}))),r})));return await m(c)})({hashs:e,userId:t,path:this.path,reason:"remote-write-cache"});return await this.write(a)}}class z extends S{#e;#t;#a;#r;#n;#s;constructor(e,t){super(),this.#e=e,this.#t=t}get id(){return this.#e}get path(){return this.#a}get name(){return this.#r}get kind(){return this.#t}get createTime(){return this.#n}get lastModified(){return this.#s||null}async root(){let e=await h(this,"root");for(;"root"!==e.parent;)e=await s({key:e.parent});const t=await new R(e.key);return await t.refresh(),t}async parent(){const e=await h(this,"parent");if("root"===e.parent)return null;const t=new R(e.parent);return await t.refresh(),t}async moveTo(e,t){[e,t]=await p({target:e,name:t,self:this});const a=await h(this,"move");a.parent=e.id,a.name=t.toLowerCase(),a.realName=t,await o({datas:[a]}),await this.refresh()}async copyTo(e,t,a){if([e,t]=await p({target:e,name:t,self:this}),!(e instanceof z))return u({source:this,target:e,name:t,callback:a});let r;switch(this.kind){case"dir":r=await e.get(t,{create:"dir"});for await(let[e,t]of this.entries())await t.copyTo(r,e);break;case"file":r=await e.get(t,{create:"file"});const a=await h(this,"move"),n=await s({key:r.id}),i=n.hashs=a.hashs;await o({datas:[{...a,...n},...i.map(((e,t)=>({key:`${n.key}-${t}`,hash:e,type:"block"})))]})}return await l(e.id),r}async remove(e){const a=await h(this,"remove");if("root"===a.parent)throw t("notDeleteRoot",{name:this.name});"dir"===this.kind&&await this.forEach((async t=>{await t.remove(e)}));const r=a.hashs||[],n=[a.key];r.forEach(((e,t)=>{n.push(`${a.key}-${t}`)})),await o({removes:n}),r.length&&await c(r),e&&e({type:"remove",path:this.path})}async refresh(){const e=await h(this,"refresh");this.#n=e.createTime,this.#s=e.lastModified,this.#r=e.realName||e.name;const t=[e.realName||e.name];let a=e;for(;"root"!==a.parent;)a=await s({key:a.parent}),t.unshift(a.realName||a.name);return this.#a=t.join("/"),{createTime:e.createTime,lastModified:e.lastModified}}async size(){const e=await h(this,"size");if("file"===e.type)return e.size}toJSON(){const e={};return["createTime","id","kind","lastModified","name","path"].forEach((t=>{e[t]=this[t]})),e}get _mark(){return"db"}}class B extends z{constructor(e){super(e,"file")}async write(e,t){const a=await this.createWritable(),r=e.length||e.size||e.byteLength||0,n=Math.ceil(r/w);return a.onbeforewrite=e=>{t&&t({...e,length:n,type:"write-file-start"})},a.onwrite=e=>{t&&t({...e,length:n,type:"write-file-end"})},await a.write(e),await a.close(),!0}async createWritable(){return new U(this.id,this.path)}async read(e,t){const a=await h(this,"读取数据"),{hashs:r}=a;let n=[];if(t&&(t.start||t.end)){let e=Math.floor(t.start/w),a=Math.floor(t.end/w);n=await Promise.all(r.map((async(r,n)=>{let i;if(n>=e&&n<=a){i=(await s({storename:"blocks",key:r})).chunk,e===a?i=i.slice(t.start-n*w,t.end-n*w):n===e?i=i.slice(-1*((e+1)*w-t.start)):n===a&&(i=i.slice(0,t.end-a*w))}return i}))),n=n.filter((e=>!!e))}else r&&(n=await Promise.all(r.map((async(e,t)=>{const a=await s({storename:"blocks",key:e}),{chunk:r}=a;return r}))));return(({u8Data:e,type:t,data:a,isChunk:r})=>"text"===t?(new TextDecoder).decode(e):"file"===t?r?new Blob([e.buffer]):new File([e.buffer],a.name,{lastModified:a.lastModified}):"base64"===t?new Promise((t=>{const r=new File([e.buffer],a.name),n=new FileReader;n.onload=()=>{t(n.result)},n.readAsDataURL(r)})):e.buffer)({u8Data:m(n),type:e,data:a,isChunk:t?.start||t?.end})}file(e){return this.read("file",e)}text(e){return this.read("text",e)}buffer(e){return this.read("buffer",e)}base64(e){return this.read("base64",e)}}class U{#i;#o=new ArrayBuffer;#c=[];#h=0;#a;constructor(e,t){this.#i=e,this.#a=t}async write(e){let t;if("string"==typeof e)t=(new TextEncoder).encode(e).buffer;else if(e instanceof Blob)t=await e.arrayBuffer();else if(e instanceof ArrayBuffer)t=e;else{if(!(e instanceof Uint8Array))throw new Error("Input must be a string, File object or ArrayBuffer object");t=e.buffer}for(this.#h+=t.byteLength,this.#o=function(e,t){const a=e.byteLength+t.byteLength,r=new ArrayBuffer(a),n=new Uint8Array(r);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),r}(this.#o,t);this.#o.byteLength>w;){const e=this.#o.slice(0,w);this.#o=this.#o.slice(w);const t=await this._writeChunk(e);this.#c.push(t)}}async _writeChunk(e){const t=await y(e),a=await s({storename:"blocks",key:t}),r={path:this.#a,index:this.#c.length,hash:t,exited:a};return this.onbeforewrite&&this.onbeforewrite({type:"onbeforewrite",...r}),a||await o({storename:"blocks",datas:[{hash:t,chunk:e}]}),this.onwrite&&this.onwrite({type:"onwrite",...r}),t}async close(){const e=await h({id:this.#i},"write");if(e){if(this.#o.byteLength>0){const e=await this._writeChunk(this.#o);this.#c.push(e)}{const t=e.hashs||[],a=this.#c,r=this.#h,n=[];for(let e=0;e<t.length;e++)e>=a.length&&n.push(`${this.#i}-${e}`);await o({datas:[{...e,lastModified:Date.now(),hashs:a,size:r},...a.map(((e,t)=>({type:"block",key:`${this.#i}-${t}`,hash:e})))],removes:n}),t.length&&await c(t),await l(e.parent)}}else await this.abort()}async abort(){this.#c&&await c(this.#c)}}class R extends z{constructor(e){super(e,"dir")}async get(e,a){if(!function(e){return!g.test(e)}(e))throw t("pathInvalid",{path:e});await h(this,"get");const n=e.split("/");if(a&&a.create&&"file"!==a.create&&"dir"!==a.create)throw t("invalidCreateType");let i=this;if(n.length>1)for(const e of n.slice(0,-1)){let r=i;if(i=await i.get(e,{create:a?.create?"dir":void 0}),!i)throw await r.refresh(),t("pathNotFound",{path:r.path+"/"+e})}let c=n.slice(-1)[0],u=await s({index:"parent_and_name",key:[i.id,c.toLowerCase()]});if(a&&a.create&&!u){const e=Date.now();u={createTime:e,lastModified:e,key:r(),realName:c,name:c.toLowerCase(),parent:i.id,type:a.create},await o({datas:[u]}),await l(i.id)}if(a&&a.create&&a.create!==u.type)throw t("targetAnotherType",{path:i.path+"/"+c,exitedType:u.type,targetType:a.create});return await F(u)}async*keys(){h(this,"keys");const e=await O(this.id);for(let t of e)yield t.name}async*entries(){h(this,"entries");const e=await O(this.id);for(let t of e)yield[t.name,await F(t)]}async*values(){h(this,"values");for await(let[,e]of this.entries())yield e}async forEach(e){h(this,"forEach");const t=await O(this.id);let a=0;for(let r of t)await e(await F(r),a),a++}async length(){h(this,"length");return await s({key:this.id,index:"parent",method:"count"})}}const O=async e=>await s({key:e,index:"parent",method:"getAll"}),F=async e=>{let t=null;if(e){switch(e.type){case"dir":t=new R(e.key);break;case"file":t=new B(e.key)}await t.refresh()}return t},q=(async()=>{await(async e=>{await s({index:"parent_and_name",key:["root",e]})||await o({datas:[{key:r(),parent:"root",name:e,createTime:Date.now()}]})})("local")})(),W=async(e,a)=>{const r=e.split("/");if(!r.length)throw t("pathEmpty");if(""===r[0])throw t("rootEmpty");await q;const n=await s({index:"parent_and_name",key:["root",r[0]]});if(!n)throw t("rootNotExist",{rootname:r[0]});const i=new R(n.key);return 1===r.length?(await i.refresh(),i):i.get(r.slice(1).join("/"),a)},J=async({request:e})=>{const{pathname:t}=new URL(e.url),a=decodeURIComponent(t.replace(/^\/\$\//,"")),r=a.split("/");if(!(3!==r.length||"apps"!==r[0]&&"packages"!==r[0]||"app"!==r[2]&&"appdebug"!==r[2]))return H({pathname:t,path:a});const n=await W(a);let s=await n.file();const i={},o=a.split(".").pop();return/^\/\$\/apps\//.test(t)&&"html"===o&&"index.html"===n.name?i["Content-Type"]="text/html; charset=utf-8":i["Content-Type"]=(e=>{switch(e){case"html":case"htm":case"txt":case"md":return"text/plain; charset=utf-8";case"js":case"mjs":return"application/javascript; charset=utf-8";case"json":return"application/json; charset=utf-8";case"css":return"text/css; charset=utf-8";case"xml":return"application/xml; charset=utf-8";case"svg":return"image/svg+xml; charset=utf-8";case"csv":return"text/csv; charset=utf-8";case"ics":return"text/calendar; charset=utf-8";case"pdf":return"application/pdf; charset=utf-8";case"doc":case"docx":return"application/msword; charset=utf-8";case"xls":case"xlsx":return"application/vnd.ms-excel; charset=utf-8";case"ppt":case"pptx":return"application/vnd.ms-powerpoint; charset=utf-8";case"zip":return"application/zip; charset=utf-8";case"gz":return"application/gzip; charset=utf-8";case"tar":return"application/x-tar; charset=utf-8";case"jpg":case"jpeg":return"image/jpeg";case"png":return"image/png";case"gif":return"image/gif";case"bmp":case"bmp":return"image/bmp";case"ico":return"image/x-icon";case"webp":return"image/webp";case"mp3":return"audio/mpeg";case"wav":return"audio/wav";case"mp4":case"m4v":return"video/mp4";case"mov":return"video/quicktime";case"avi":return"video/x-msvideo";default:return"application/octet-stream"}})(o),new Response(s,{status:200,headers:i})},H=async({pathname:e,path:t})=>{let a;const r=t.split("/"),n=r.slice(0,-1).join("/"),s="appdebug"===r.slice(-1)[0];try{a=await W(`${n}/app.json`),a=JSON.parse(await a.text())}catch(e){a=await fetch(`/${n}/app.json`).then((e=>e.json()))}return new Response(`<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="apple-mobile-web-app-capable" content="yes" />\n    <meta name="mobile-web-app-capable" content="yes" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />\n    <title>${a.name}</title>\n    <link rel="shortcut icon" href="${a.icon}">\n    <link rel="apple-touch-icon" href="${a.icon}" />\n    <script src="/packages/libs/ofa/ofa.js"${s?" debug":""}><\/script>\n    <script src="/packages/libs/ofa/router.min.js"><\/script>\n    <script src="/packages/pui/init.js" type="module"><\/script>\n    <style>\n      html,\n      body {\n        margin: 0;\n        padding: 0;\n        height: 100%;\n      }\n\n      o-app {\n        height: 100%;\n      }\n    </style>\n  </head>\n  <body>\n    <o-router fix-body>\n      <o-app src="${a.config}"></o-app>\n    </o-router>\n    <o-root-provider name="pui" theme="dark"></o-root-provider>\n    <o-root-provider name="clipboard" type="no"></o-root-provider>\n  </body>\n</html>\n    `,{status:200,headers:{"Content-Type":"text/html; charset=utf-8"}})};self.addEventListener("fetch",(e=>{const{request:t}=e,{pathname:a,origin:r}=new URL(t.url);location.origin===r&&("/"===a||"/index.html"===a?e.respondWith((async e=>{const t=await caches.open("noneos-default-cache");let a=await t.match(e);return a?a.clone():(a=await fetch(e),200===a.status&&t.put(e,a.clone()),a)})(a)):/^\/\$/.test(a)?e.respondWith((async()=>{try{return await J({request:t})}catch(e){return console.error(e),new Response(e.stack||e.toString(),{status:404})}})()):/^\/packages\//.test(a)&&e.respondWith((async()=>{try{return await J({request:{url:`${r}/$${a}`}})}catch(e){return fetch(t.url)}})()))})),self.addEventListener("install",(()=>{self.skipWaiting(),console.log("NoneOS installation successful")})),self.addEventListener("activate",(()=>{self.clients.claim(),console.log("NoneOS server activation successful")}))}();
