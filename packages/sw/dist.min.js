!function(){"use strict";const e={pathEmpty:"文件路径不能为空",indexErr:"在数据库{dbname}的{storename}表中没有找到索引{key}",setDataErr:"设置数据出错",findDataErr:"查找数据出错",getDataErr:"获取数据出错",rootEmpty:"不允许使用 '/' 开头的路径",rootNotExist:"根目录 {rootname} 不存在",pathNotFound:"未找到文件夹:{path}",storeNotExistMethod:"store中不存在方法 {method}",invalidCreateType:"create必须等于'file'或'dir'",notDeleteRoot:"不能直接删除根节点{name}",deleted:"当前handle已被删除，不能使用{name}；旧地址为:{path}",exitedName:"操作失败，{name}已经存在",tolowcase:"文件系统对大小写不敏感，{oldName}将会被转为{newName}",writefile:"写入文件内容失败:{path}",noPicker:"当前浏览器不支持文件选择",targetAnotherType:"{path} 已经是一个'{exitedType}'，不能创建为'{targetType}'",notMoveToChild:"{targetPath} 是 {path} 的子目录，不能移动到自己的子目录",notFoundChunk:"{path}文件没有找到对应的块文件:{hash}"},t=(t,a,r)=>{let n,s=e[t];if(a)for(let e in a)s=s.replace(new RegExp(`{${e}}`,"g"),a[e]);return n=r?new Error(s,{cause:r}):new Error(s),n.code=t,n},a={};function r(e=10){const t=new Uint8Array(e);return crypto.getRandomValues(t),Array.from(t,(e=>("0"+e.toString(32)).slice(-2))).join("")}const n=async(e="noneos_fs_defaults")=>(a[e]||(a[e]=new Promise((t=>{const r=indexedDB.open(e);r.onsuccess=async r=>{const n=r.target.result;n.onclose=()=>{a[e]=null},t(n)},r.onupgradeneeded=e=>{const t=e.target.result,a=t.createObjectStore("main",{keyPath:"key"});a.createIndex("parent","parent",{unique:!1}),a.createIndex("parent_and_name",["parent","name"],{unique:!0}),a.createIndex("hash","hash",{unique:!1}),t.createObjectStore("blocks",{keyPath:"hash"})},r.onerror=t=>{throw new Event(e+" creation error",{cause:t.error})}}))),a[e]),s=async({dbname:e="noneos_fs_defaults",storename:a="main",index:r,all:s=!1,method:i="get",key:o})=>{let c=await(async({storename:e,index:a,dbname:r})=>{let s=(await n(r)).transaction([e],"readonly").objectStore(e);if(a)try{s=s.index(a)}catch(n){throw t("indexErr",{dbname:r,storename:e,key:a},n)}return s})({storename:a,index:r,dbname:e});if(!c[i])throw t("storeNotExistMethod",{method:i});return new Promise(((e,a)=>{c=c[i](o),c.onsuccess=t=>{e(t.target.result)},c.onerror=e=>{a(t("getDataErr",null,e.target.error))}}))},i=new Map,o=async({dbname:e="noneos_fs_defaults",storename:a="main",datas:r,removes:s})=>{if(!r?.length&&!s?.length)return!0;const o=await n(e);return new Promise(((e,n)=>{const c=o.transaction([a],"readwrite");c.oncomplete=t=>{r&&r.forEach((e=>{e.parent&&i.delete(`${e.parent}-${e.name}`)})),e(!0)},c.onerror=e=>{n(t("setDataErr",null,e.target.error))};const h=c.objectStore(a);r&&r.forEach((e=>{if(e.parent){const t=i.get(`${e.parent}-${e.name}`);if(t){const a=t;Object.assign(e,a)}else i.set(`${e.parent}-${e.name}`,e)}h.put(e)})),s&&s.length&&s.forEach((e=>h.delete(e)))}))},c=async e=>{const t=[];await Promise.all(e.map((async e=>{!await s({index:"hash",key:e})&&t.push(e)}))),t.length&&await o({storename:"blocks",removes:t})},h=async(e,a)=>{const r=await s({key:e.id});if(!r)throw t("deleted",{name:a,path:e.path},e);return r},l=async e=>{const t=[],a=Date.now();let r=e;for(;r;){const e=await s({key:r});if(!e)break;e.lastModified=a,t.push(e),r=e.parent}await o({datas:t})},p=1048576,f=async(e,t=1048576)=>{let a;if("string"==typeof e)a=(new TextEncoder).encode(e).buffer;else if(e instanceof File)a=await e.arrayBuffer();else{if(!(e instanceof ArrayBuffer))throw new Error("Input must be a string, File object or ArrayBuffer object");a=e}const r=[];for(let e=0;e<a.byteLength;e+=t){const n=a.slice(e,e+t);r.push(n)}return r},d=async e=>{const t=await crypto.subtle.digest("SHA-256",e),a=Array.from(new Uint8Array(t)).map((e=>e.toString(16).padStart(2,"0"))).join(""),r=Math.floor(e.byteLength/2);return a+new Uint8Array(e.slice(r,r+1))[0].toString(16)},u=async({source:e,target:t,name:a,callback:r})=>{if([t,a]=await w({target:t,name:a,self:e}),"file"===e.kind){const n=await e.file(),s=await t.get(a,{create:"file"});return await s.write(n,r),s}if("dir"===e.kind){const n=await t.get(a,{create:"dir"});return await e.forEach((async e=>{await u({source:e,target:n,name:e.name,callback:r})})),n}},w=async({target:e,name:a,self:r})=>{"string"==typeof e&&(a=e,e=await r.parent()),a||(a=r.name);let n=!1;for await(let t of e.keys())if(a===t){n=1;break}if(n)throw t("exitedName",{name:`${a}(${e.path}/${a})`});if(function(e,t){if(e===t)return!1;const a=t.split("/").filter((e=>e.length)),r=e.split("/").filter((e=>e.length));return a.every(((e,t)=>r[t]===e))}(e.path,r.path))throw t("notMoveToChild",{targetPath:e.path,path:r.path});return[e,a]};class m{constructor(){}async _getHashMap(e={}){const t=e.size||65536,a=await this.buffer(),r=await f(a,t),n=await Promise.all(r.map((async e=>await d(e))));return[{bridgefile:1,size:await this.size()},...n]}async _getChunk(e,t,a){if(a||(a=65536),void 0!==t){const r=await this.buffer({start:t*a,end:(t+1)*a});if(await d(r)===e)return r}const r=await this.file(),n=new Map,s=await f(r,a);return await Promise.all(s.map((async e=>{const t=await d(e);n.set(t,e)}))),n.get(e)}}class y extends m{#e;#t;#a;#r;#n;#s;constructor(e,t){super(),this.#e=e,this.#t=t}get id(){return this.#e}get path(){return this.#a}get name(){return this.#r}get kind(){return this.#t}get createTime(){return this.#n}get lastModified(){return this.#s||null}async root(){let e=await h(this,"root");for(;"root"!==e.parent;)e=await s({key:e.parent});const t=await new k(e.key);return await t.refresh(),t}async parent(){const e=await h(this,"parent");if("root"===e.parent)return null;const t=new k(e.parent);return await t.refresh(),t}async moveTo(e,t){[e,t]=await w({target:e,name:t,self:this});const a=await h(this,"move");a.parent=e.id,a.name=t.toLowerCase(),a.realName=t,await o({datas:[a]}),await this.refresh()}async copyTo(e,t,a){if([e,t]=await w({target:e,name:t,self:this}),!(e instanceof y))return u({source:this,target:e,name:t,callback:a});let r;switch(this.kind){case"dir":r=await e.get(t,{create:"dir"});for await(let[e,t]of this.entries())await t.copyTo(r,e);break;case"file":r=await e.get(t,{create:"file"});const a=await h(this,"move"),n=await s({key:r.id}),i=n.hashs=a.hashs;await o({datas:[{...a,...n},...i.map(((e,t)=>({key:`${n.key}-${t}`,hash:e,type:"block"})))]})}return await l(e.id),r}async remove(){const e=await h(this,"remove");if("root"===e.parent)throw t("notDeleteRoot",{name:this.name});"dir"===this.kind&&await this.forEach((async e=>{await e.remove()}));const a=e.hashs||[],r=[e.key];a.forEach(((t,a)=>{r.push(`${e.key}-${a}`)})),await o({removes:r}),a.length&&await c(a)}async refresh(){const e=await h(this,"refresh");this.#n=e.createTime,this.#s=e.lastModified,this.#r=e.realName||e.name;const t=[e.realName||e.name];let a=e;for(;"root"!==a.parent;)a=await s({key:a.parent}),t.unshift(a.realName||a.name);this.#a=t.join("/")}async size(){const e=await h(this,"size");if("file"===e.type)return e.size}toJSON(){const e={};return["createTime","id","kind","lastModified","name","path"].forEach((t=>{e[t]=this[t]})),e}get _mark(){return"db"}}class g extends y{constructor(e){super(e,"file")}async write(e,t){const a=await this.createWritable(),r=e.length||e.size||e.byteLength||0,n=Math.ceil(r/p);a.onbeforewrite=e=>{t&&t({...e,length:n,type:"write-file-start"})},a.onwrite=e=>{t&&t({...e,length:n,type:"write-file-end"})},await a.write(e),await a.close()}createWritable(){return new b(this.id,this.path)}async read(e,t){const a=await h(this,"读取数据"),{hashs:r}=a;let n=[];if(t&&(t.start||t.end)){let e=Math.floor(t.start/p),a=Math.floor(t.end/p);n=await Promise.all(r.map((async(r,n)=>{let i;if(n>=e&&n<=a){i=(await s({storename:"blocks",key:r})).chunk,e===a?i=i.slice(t.start-n*p,t.end-n*p):n===e?i=i.slice(-1*((e+1)*p-t.start)):n===a&&(i=i.slice(0,t.end-a*p))}return i}))),n=n.filter((e=>!!e))}else r&&(n=await Promise.all(r.map((async(e,t)=>{const{chunk:a}=await s({storename:"blocks",key:e});return a}))));const i=(e=>{const t=e.reduce(((e,t)=>e+t.byteLength),0),a=new Uint8Array(t);let r=0;return e.forEach((e=>{a.set(new Uint8Array(e),r),r+=e.byteLength})),a})(n);return(({buffer:e,type:t,data:a,isChunk:r})=>"text"===t?(new TextDecoder).decode(e):"file"===t?r?new Blob([e.buffer]):new File([e.buffer],a.name,{lastModified:a.lastModified}):"base64"===t?new Promise((t=>{const r=new File([e.buffer],a.name),n=new FileReader;n.onload=()=>{t(n.result)},n.readAsDataURL(r)})):e.buffer)({buffer:i,type:e,data:a,isChunk:t?.start||t?.end})}file(e){return this.read("file",e)}text(e){return this.read("text",e)}buffer(e){return this.read("buffer",e)}base64(e){return this.read("base64",e)}}class b{#i;#o=new ArrayBuffer;#c=[];#h=0;#a;constructor(e,t){this.#i=e,this.#a=t}async write(e){let t;for("string"==typeof e?t=(new TextEncoder).encode(e).buffer:e instanceof File?t=await e.arrayBuffer():e instanceof ArrayBuffer&&(t=e),this.#h+=t.byteLength,this.#o=function(e,t){const a=e.byteLength+t.byteLength,r=new ArrayBuffer(a),n=new Uint8Array(r);return n.set(new Uint8Array(e),0),n.set(new Uint8Array(t),e.byteLength),r}(this.#o,t);this.#o.byteLength>p;){const e=this.#o.slice(0,p);this.#o=this.#o.slice(p);const t=await this._writeChunk(e);this.#c.push(t)}}async _writeChunk(e){const t=await d(e),a=await s({storename:"blocks",key:t}),r={path:this.#a,index:this.#c.length,hash:t,exited:a};return this.onbeforewrite&&this.onbeforewrite({type:"onbeforewrite",...r}),a||await o({storename:"blocks",datas:[{hash:t,chunk:e}]}),this.onwrite&&this.onwrite({type:"onwrite",...r}),t}async close(){const e=await h({id:this.#i},"write");if(e){if(this.#o.byteLength>0){const e=await this._writeChunk(this.#o);this.#c.push(e)}{const t=e.hashs||[],a=this.#c,r=this.#h,n=[];for(let e=0;e<t.length;e++)e>=a.length&&n.push(`${this.#i}-${e}`);await o({datas:[{...e,lastModified:Date.now(),hashs:a,size:r},...a.map(((e,t)=>({type:"block",key:`${this.#i}-${t}`,hash:e})))],removes:n}),t.length&&await c(t),await l(e.parent)}}else await this.abort()}async abort(){this.#c&&await c(this.#c)}}class k extends y{constructor(e){super(e,"dir")}async get(e,a){await h(this,"get");const n=e.split("/");if(a&&a.create&&"file"!==a.create&&"dir"!==a.create)throw t("invalidCreateType");let i=this;if(n.length>1)for(const e of n.slice(0,-1)){let r=i;if(i=await i.get(e,{create:a?.create?"dir":void 0}),!i)throw await r.refresh(),t("pathNotFound",{path:r.path+"/"+e})}let c=n.slice(-1)[0],p=await s({index:"parent_and_name",key:[i.id,c.toLowerCase()]});if(a&&a.create&&!p){const e=Date.now();p={createTime:e,lastModified:e,key:r(),realName:c,name:c.toLowerCase(),parent:i.id,type:a.create},await o({datas:[p]}),await l(i.id)}if(a&&a.create&&a.create!==p.type)throw t("targetAnotherType",{path:i.path+"/"+c,exitedType:p.type,targetType:a.create});return await v(p)}async*keys(){h(this,"keys");const e=await x(this.id);for(let t of e)yield t.name}async*entries(){h(this,"entries");const e=await x(this.id);for(let t of e)yield[t.name,await v(t)]}async*values(){h(this,"values");for await(let[,e]of this.entries())yield e}async forEach(e){h(this,"forEach");const t=await x(this.id);let a=0;for(let r of t)await e(await v(r),a),a++}async length(){h(this,"length");return await s({key:this.id,index:"parent",method:"count"})}}const x=async e=>await s({key:e,index:"parent",method:"getAll"}),v=async e=>{let t=null;if(e){switch(e.type){case"dir":t=new k(e.key);break;case"file":t=new g(e.key)}await t.refresh()}return t},E=(async()=>{await(async e=>{await s({index:"parent_and_name",key:["root",e]})||await o({datas:[{key:r(),parent:"root",name:e,createTime:Date.now()}]})})("local")})(),$=async(e,a)=>{const r=e.split("/");if(!r.length)throw t("pathEmpty");if(""===r[0])throw t("rootEmpty");await E;const n=await s({index:"parent_and_name",key:["root",r[0]]});if(!n)throw t("rootNotExist",{rootname:r[0]});const i=new k(n.key);return 1===r.length?(await i.refresh(),i):i.get(r.slice(1).join("/"),a)},T=async({request:e})=>{const{pathname:t}=new URL(e.url),a=decodeURIComponent(t.replace(/^\/\$\//,"")),r=a.split("/");if(!(3!==r.length||"apps"!==r[0]&&"packages"!==r[0]||"app"!==r[2]&&"appdebug"!==r[2]))return j({pathname:t,path:a});const n=await $(a);let s=await n.file();const i={},o=a.split(".").pop();return/^\/\$\/apps\//.test(t)&&"html"===o&&"index.html"===n.name?i["Content-Type"]="text/html; charset=utf-8":i["Content-Type"]=(e=>{switch(e){case"html":case"htm":case"txt":case"md":return"text/plain; charset=utf-8";case"js":case"mjs":return"application/javascript; charset=utf-8";case"json":return"application/json; charset=utf-8";case"css":return"text/css; charset=utf-8";case"xml":return"application/xml; charset=utf-8";case"svg":return"image/svg+xml; charset=utf-8";case"csv":return"text/csv; charset=utf-8";case"ics":return"text/calendar; charset=utf-8";case"pdf":return"application/pdf; charset=utf-8";case"doc":case"docx":return"application/msword; charset=utf-8";case"xls":case"xlsx":return"application/vnd.ms-excel; charset=utf-8";case"ppt":case"pptx":return"application/vnd.ms-powerpoint; charset=utf-8";case"zip":return"application/zip; charset=utf-8";case"gz":return"application/gzip; charset=utf-8";case"tar":return"application/x-tar; charset=utf-8";case"jpg":case"jpeg":return"image/jpeg";case"png":return"image/png";case"gif":return"image/gif";case"bmp":case"bmp":return"image/bmp";case"ico":return"image/x-icon";case"webp":return"image/webp";case"mp3":return"audio/mpeg";case"wav":return"audio/wav";case"mp4":case"m4v":return"video/mp4";case"mov":return"video/quicktime";case"avi":return"video/x-msvideo";default:return"application/octet-stream"}})(o),new Response(s,{status:200,headers:i})},j=async({pathname:e,path:t})=>{let a;const r=t.split("/"),n=r.slice(0,-1).join("/"),s="appdebug"===r.slice(-1)[0];try{a=await $(`${n}/app.json`),a=JSON.parse(await a.text())}catch(e){a=await fetch(`/${n}/app.json`).then((e=>e.json()))}return new Response(`<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="apple-mobile-web-app-capable" content="yes" />\n    <meta name="mobile-web-app-capable" content="yes" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />\n    <title>${a.name}</title>\n    <link rel="shortcut icon" href="${a.icon}">\n    <link rel="apple-touch-icon" href="${a.icon}" />\n    <script src="/packages/ofa/ofa.js"${s?" debug":""}><\/script>\n    <script src="/packages/ofa/router.min.js"><\/script>\n    <script src="/packages/pui/init.js" type="module"><\/script>\n    <style>\n      html,\n      body {\n        margin: 0;\n        padding: 0;\n        height: 100%;\n      }\n\n      o-app {\n        height: 100%;\n      }\n    </style>\n  </head>\n  <body>\n    <o-router fix-body>\n      <o-app src="${a.config}"></o-app>\n    </o-router>\n    <o-root-provider name="pui" theme="dark"></o-root-provider>\n    <o-root-provider name="clipboard" type="no"></o-root-provider>\n  </body>\n</html>\n    `,{status:200,headers:{"Content-Type":"text/html; charset=utf-8"}})};self.addEventListener("fetch",(e=>{const{request:t}=e,{pathname:a,origin:r}=new URL(t.url);location.origin===r&&("/"===a||"/index.html"===a?e.respondWith((async e=>{const t=await caches.open("noneos-default-cache");let a=await t.match(e);return a?a.clone():(a=await fetch(e),200===a.status&&t.put(e,a.clone()),a)})(a)):/^\/\$/.test(a)?e.respondWith((async()=>{try{return await T({request:t})}catch(e){return console.error(e),new Response(e.stack||e.toString(),{status:404})}})()):/^\/packages\//.test(a)&&e.respondWith((async()=>{try{return await T({request:{url:`${r}/$${a}`}})}catch(e){return fetch(t.url)}})()))})),self.addEventListener("install",(()=>{self.skipWaiting(),console.log("NoneOS installation successful")})),self.addEventListener("activate",(()=>{self.clients.claim(),console.log("NoneOS server activation successful")}))}();
