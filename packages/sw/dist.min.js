!function(){"use strict";const e={pathEmpty:"文件路径不能为空",indexErr:"在数据库{dbname}的{storename}表中没有找到索引{key}",setDataErr:"设置数据出错",findDataErr:"查找数据出错",getDataErr:"获取数据出错",rootEmpty:"不允许使用 '/' 开头的路径",rootNotExist:"根目录 {rootname} 不存在",pathNotFound:"未找到文件夹:{path}",storeNotExistMethod:"store中不存在方法 {method}",invalidCreateType:"create必须等于'file'或'dir'",notDeleteRoot:"不能直接删除根节点{name}",deleted:"当前handle已被删除，不能使用{name}；旧地址为:{path}",exitedName:"操作失败，{name}已经存在"},t=(t,a,r)=>{let n,s=e[t];if(a)for(let e in a)s=s.replace(new RegExp(`{${e}}`,"g"),a[e]);return n=r?new Error(s,{cause:r}):new Error(s),n},a={};function r(e=10){const t=new Uint8Array(e);return crypto.getRandomValues(t),Array.from(t,(e=>("0"+e.toString(32)).slice(-2))).join("")}const n=async(e="noneos_fs_defaults")=>(a[e]||(a[e]=new Promise((t=>{const r=indexedDB.open(e);r.onsuccess=async r=>{const n=r.target.result;n.onclose=()=>{a[e]=null},t(n)},r.onupgradeneeded=e=>{const t=e.target.result,a=t.createObjectStore("main",{keyPath:"key"});a.createIndex("parent","parent",{unique:!1}),a.createIndex("parent_and_name",["parent","name"],{unique:!0}),a.createIndex("hash","hash",{unique:!1}),t.createObjectStore("blocks",{keyPath:"hash"})},r.onerror=t=>{throw new Event(e+" creation error",{cause:t.error})}}))),a[e]),s=async({dbname:e="noneos_fs_defaults",storename:a="main",index:r,all:s=!1,method:i="get",key:o})=>{let c=await(async({storename:e,index:a,dbname:r})=>{let s=(await n(r)).transaction([e],"readonly").objectStore(e);if(a)try{s=s.index(a)}catch(n){throw t("indexErr",{dbname:r,storename:e,key:a},n)}return s})({storename:a,index:r,dbname:e});if(!c[i])throw t("storeNotExistMethod",{method:i});return new Promise(((e,a)=>{c=c[i](o),c.onsuccess=t=>{e(t.target.result)},c.onerror=e=>{a(t("getDataErr",null,e.target.error))}}))},i=async({dbname:e="noneos_fs_defaults",storename:a="main",datas:r,removes:s})=>{if(!r?.length&&!s?.length)return!0;const i=await n(e);return new Promise(((e,n)=>{const o=i.transaction([a],"readwrite");o.oncomplete=t=>{e(!0)},o.onerror=e=>{n(t("setDataErr",null,e.target.error))};const c=o.objectStore(a);r&&r.length&&r.forEach((e=>c.put(e))),s&&s.length&&s.forEach((e=>c.delete(e)))}))},o=async e=>{const t=[];await Promise.all(e.map((async e=>{!await s({index:"hash",key:e})&&t.push(e)}))),t.length&&await i({storename:"blocks",removes:t})},c=async(e,a)=>{const r=await s({key:e.id});if(!r)throw t("deleted",{name:a,path:e.path},e);return r},l=Symbol("kind");class h{#e;#t;#a;constructor(e){this.#e=e}get id(){return this.#e}get path(){return this.#t}get name(){return this.#a}get kind(){return this[l]}async root(){let e=await c(this,"root");for(;"root"!==e.parent;)e=await s({key:e.parent});const t=await new p(e.key);return await t.refresh(),t}async parent(){const e=await c(this,"parent");if("root"===e.parent)return null;const t=new p(e.parent);return await t.refresh(),t}async move(e,t){[e,t]=await d({target:e,name:t,self:this});const a=await c(this,"move");a.parent=e.id,a.name=t,await i({datas:[a]}),await this.refresh()}async copy(e,t){let a;switch([e,t]=await d({target:e,name:t,self:this}),this.kind){case"dir":a=await e.get(t,{create:"dir"});for await(let[e,t]of this.entries())await t.copy(a,e);break;case"file":a=await e.get(t,{create:"file"});const r=await c(this,"move"),n=await s({key:a.id}),o=n.hashs=r.hashs;await i({datas:[n,...o.map(((e,t)=>({key:`${n.key}-${t}`,hash:e,type:"block"})))]})}return a}async remove(){const e=await c(this,"remove");if("root"===e.parent)throw t("notDeleteRoot",{name:this.name});"dir"===this.kind&&await this.forEach((async e=>{await e.remove()}));const a=e.hashs||[],r=[e.key];a.forEach(((t,a)=>{r.push(`${e.key}-${a}`)})),await i({removes:r}),a.length&&await o(a)}async refresh(){const e=await c(this,"refresh");this.#a=e.realName||e.name;const t=[e.realName||e.name];let a=e;for(;"root"!==a.parent;)a=await s({key:a.parent}),t.unshift(a.realName||a.name);this.#t=t.join("/")}}const d=async({target:e,name:a,self:r})=>{"string"==typeof e&&(a=e,e=await r.parent());let n=!1;for await(let t of e.keys())if(a===t){n=1;break}if(n)throw t("exitedName",{name:`${a}(${e.path}/${a})`});return[e,a]},f=1048576;class w extends h{constructor(e){super(e),this[l]="file"}async write(e,t){const a=await c(this,"write"),r=t?.process||(()=>{}),n=await y(e),l=[];await Promise.all(n.map((async(e,t)=>{const a=await m(e);l[t]=a;const o=await s({storename:"blocks",key:a});o||await i({storename:"blocks",datas:[{hash:a,chunk:e}]}),r({index:t,length:n.length,hash:a,exited:o})})));const h=a.hashs||[],d=[];for(let e=0;e<h.length;e++)e>=l.length&&d.push(`${this.id}-${e}`);await i({datas:[{...a,lastModified:e?.lastModified||Date.now(),length:e.length,hashs:l},...l.map(((e,t)=>({type:"block",key:`${this.id}-${t}`,hash:e})))],removes:d}),h.length&&await o(h)}async read(e,t){const a=await c(this,"读取数据"),{hashs:r}=a;let n;if(t&&(t.start||t.end)){let e=Math.floor(t.start/f),a=Math.floor(t.end/f);n=await Promise.all(r.map((async(r,n)=>{let i;if(n>=e&&n<=a){i=(await s({storename:"blocks",key:r})).chunk,e===a?i=i.slice(t.start-n*f,t.end-n*f):n===e?i=i.slice(-1*((e+1)*f-t.start)):n===a&&(i=i.slice(0,t.end-a*f))}return i}))),n=n.filter((e=>!!e))}else n=await Promise.all(r.map((async(e,t)=>{const{chunk:a}=await s({storename:"blocks",key:e});return a})));const i=u(n);if("text"===e)return(new TextDecoder).decode(i);if("file"===e)return t?.start||t?.end?new Blob([i.buffer]):new File([i.buffer],a.name,{lastModified:a.lastModified});if("base64"===e){let e="",t=i.byteLength;for(let a=0;a<t;a++)e+=String.fromCharCode(i[a]);return`data:application/javascript;base64,${btoa(e)}`}return i.buffer}file(e){return this.read("file",e)}text(e){return this.read("text",e)}buffer(e){return this.read("buffer",e)}base64(e){return this.read("base64",e)}}const y=async e=>{let t;if("string"==typeof e)t=(new TextEncoder).encode(e).buffer;else if(e instanceof File)t=await e.arrayBuffer();else{if(!(e instanceof ArrayBuffer))throw new Error("Input must be a string, File object or ArrayBuffer object");t=e}const a=[];for(let e=0;e<t.byteLength;e+=f){const r=t.slice(e,e+f);a.push(r)}return a},u=e=>{const t=e.reduce(((e,t)=>e+t.byteLength),0),a=new Uint8Array(t);let r=0;return e.forEach((e=>{a.set(new Uint8Array(e),r),r+=e.byteLength})),a},m=async e=>{const t=await crypto.subtle.digest("SHA-256",e),a=Array.from(new Uint8Array(t)).map((e=>e.toString(16).padStart(2,"0"))).join(""),r=Math.floor(e.byteLength/2);return a+new Uint8Array(e.slice(r,r+1))[0].toString(16)};class p extends h{constructor(e){super(e),this[l]="dir"}async get(e,a){await c(this,"get");const n=e.split("/");if(a&&a.create&&"file"!==a.create&&"dir"!==a.create)throw t("invalidCreateType");let o=this;if(n.length>1)for(const e of n.slice(0,-1)){let r=o;if(o=await o.get(e,{create:a?.create&&"dir"}),!o)throw await r.refresh(),t("pathNotFound",{path:r.path+"/"+e})}let l=n.slice(-1)[0],h=await s({index:"parent_and_name",key:[o.id,l.toLowerCase()]});return a&&a.create&&!h&&(h={createTime:Date.now(),key:r(),realName:l,name:l.toLowerCase(),parent:o.id,type:a.create},await i({datas:[h]})),await k(h)}async*keys(){c(this,"keys");const e=await g(this.id);for(let t of e)yield t.name}async*entries(){c(this,"entries");const e=await g(this.id);for(let t of e)yield[t.name,await k(t)]}async*values(){c(this,"values");for await(let[,e]of this.entries())yield e}async forEach(e){c(this,"forEach");const t=await g(this.id);let a=0;for(let r of t)await e(await k(r),a),a++}async length(){c(this,"length");return await s({key:this.id,index:"parent",method:"count"})}}const g=async e=>await s({key:e,index:"parent",method:"getAll"}),k=async e=>{let t=null;if(e){switch(e.type){case"dir":t=new p(e.key);break;case"file":t=new w(e.key)}await t.refresh()}return t},b=(async()=>{await s({index:"parent_and_name",key:["root","local"]})||await i({datas:[{key:r(),parent:"root",name:"local",createTime:Date.now()}]})})(),x=async({request:e})=>{const{pathname:a}=new URL(e.url),r=a.replace(/^\/\$\//,"");console.log("path:",r);const n=await(async(e,a)=>{const r=e.split("/");if(!r.length)throw t("pathEmpty");if(""===r[0])throw t("rootEmpty");await b;const n=await s({index:"parent_and_name",key:["root",r[0]]});if(!n)throw t("rootNotExist",{rootname:r[0]});const i=new p(n.key);return 1===r.length?(await i.refresh(),i):i.get(r.slice(1).join("/"),a)})(r),i=await n.text();return new Response(i,{status:200,headers:{}})};self.addEventListener("fetch",(e=>{const{request:t}=e,{pathname:a}=new URL(t.url);/^\/\$/.test(a)&&e.respondWith((async()=>{try{return await x({request:t})}catch(e){return console.error(e),new Response(e.toString(),{status:404})}})())})),self.addEventListener("install",(()=>{self.skipWaiting(),console.log("NoneOS installation successful")})),self.addEventListener("activate",(()=>{console.log("NoneOS server activation successful")}))}();
