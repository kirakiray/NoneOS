!function(){"use strict";const e={pathEmpty:"文件路径不能为空",indexErr:"在数据库{dbname}的{storename}表中没有找到索引{key}",setDataErr:"设置数据出错",findDataErr:"查找数据出错",getDataErr:"获取数据出错",rootEmpty:"不允许使用 '/' 开头的路径",rootNotExist:"根目录 {rootname} 不存在",pathNotFound:"未找到文件夹:{path}",storeNotExistMethod:"store中不存在方法 {method}",invalidCreateType:"create必须等于'file'或'dir'",notDeleteRoot:"不能直接删除根节点{name}",deleted:"当前handle已被删除，不能使用{name}；旧地址为:{path}",exitedName:"操作失败，{name}已经存在",tolowcase:"文件系统对大小写不敏感，{oldName}将会被转为{newName}",writefile:"写入文件内容失败:{path}",noPicker:"当前浏览器不支持文件选择",targetAnotherType:"{path} 已经是一个'{exitedType}'，不能创建为'{targetType}'",notMoveToChild:"{targetPath} 是 {path} 的子目录，不能移动到自己的子目录",notFoundChunk:"{path}文件没有找到对应的块文件:{hash}",pathInvalid:"路径不能包含特殊字符 {path}"},t=(t,a,n)=>{let r,s=e[t];if(a)for(let e in a)s=s.replace(new RegExp(`{${e}}`,"g"),a[e]);return r=n?new Error(s,{cause:n}):new Error(s),r.code=t,r},a={};function n(e=10){const t=new Uint8Array(e);return crypto.getRandomValues(t),Array.from(t,(e=>("0"+e.toString(32)).slice(-2))).join("")}const r=async(e="noneos_fs_defaults")=>(a[e]||(a[e]=new Promise((t=>{const n=indexedDB.open(e);n.onsuccess=async n=>{const r=n.target.result;r.onclose=()=>{a[e]=null},t(r)},n.onupgradeneeded=e=>{const t=e.target.result,a=t.createObjectStore("main",{keyPath:"key"});a.createIndex("parent","parent",{unique:!1}),a.createIndex("parent_and_name",["parent","name"],{unique:!0}),a.createIndex("hash","hash",{unique:!1}),t.createObjectStore("blocks",{keyPath:"hash"})},n.onerror=t=>{throw new Event(e+" creation error",{cause:t.error})}}))),a[e]),s=async({dbname:e="noneos_fs_defaults",storename:a="main",index:n,all:s=!1,method:i="get",key:o})=>{let c=await(async({storename:e,index:a,dbname:n})=>{let s=(await r(n)).transaction([e],"readonly").objectStore(e);if(a)try{s=s.index(a)}catch(r){throw t("indexErr",{dbname:n,storename:e,key:a},r)}return s})({storename:a,index:n,dbname:e});if(!c[i])throw t("storeNotExistMethod",{method:i});return new Promise(((e,a)=>{c=c[i](o),c.onsuccess=t=>{e(t.target.result)},c.onerror=e=>{a(t("getDataErr",null,e.target.error))}}))},i=new Map,o=async({dbname:e="noneos_fs_defaults",storename:a="main",datas:n,removes:s})=>{if(!n?.length&&!s?.length)return!0;const o=await r(e);return new Promise(((e,r)=>{const c=o.transaction([a],"readwrite");c.oncomplete=t=>{n&&n.forEach((e=>{e.parent&&i.delete(`${e.parent}-${e.name}`)})),e(!0)},c.onerror=e=>{r(t("setDataErr",null,e.target.error))};const h=c.objectStore(a);n&&n.forEach((e=>{if(e.parent){const t=i.get(`${e.parent}-${e.name}`);if(t){const a=t;Object.assign(e,a)}else i.set(`${e.parent}-${e.name}`,e)}h.put(e)})),s&&s.length&&s.forEach((e=>h.delete(e)))}))},c=async e=>{const t=[];await Promise.all(e.map((async e=>{!await s({index:"hash",key:e})&&t.push(e)}))),t.length&&await o({storename:"blocks",removes:t})},h=async(e,a)=>{const n=await s({key:e.id});if(!n)throw t("deleted",{name:a,path:e.path},e);return n},l=async e=>{const t=[],a=Date.now();let n=e;for(;n;){const e=await s({key:n});if(!e)break;e.lastModified=a,t.push(e),n=e.parent}await o({datas:t})},p=async({source:e,target:t,name:a,callback:n})=>{if([t,a]=await u({target:t,name:a,self:e}),"file"===e.kind){const r=await e.file(),s=await t.get(a,{create:"file"});return await s.write(r,n),s}if("dir"===e.kind){const r=await t.get(a,{create:"dir"});return await e.forEach((async e=>{await p({source:e,target:r,name:e.name,callback:n})})),r}},u=async({target:e,name:a,self:n})=>{"string"==typeof e&&(a=e,e=await n.parent()),a||(a=n.name);let r=!1;for await(let t of e.keys())if(a===t){r=1;break}if(r)throw t("exitedName",{name:`${a}(${e.path}/${a})`});if(function(e,t){if(e===t)return!1;const a=t.split("/").filter((e=>e.length)),n=e.split("/").filter((e=>e.length));return a.every(((e,t)=>n[t]===e))}(e.path,n.path))throw t("notMoveToChild",{targetPath:e.path,path:n.path});return[e,a]};const d=async e=>{if("file"===e.kind)return[await w(e)];const t=[];for await(let a of e.values())if("dir"===a.kind){const e=await d(a);t.push(...e)}else t.push(await w(a));return t},w=async e=>{const t={size:await e.size(),path:e.path};return Object.defineProperty(t,"handle",{get:()=>e}),t},f=1048576,m=async e=>{if("string"==typeof e){e=(new TextEncoder).encode(e)}else e instanceof Blob&&(e=await(t=e,new Promise(((e,a)=>{const n=new FileReader;n.onloadend=()=>{e(new Uint8Array(n.result))},n.onerror=a,n.readAsArrayBuffer(t)}))));var t;const a=await crypto.subtle.digest("SHA-256",e);return Array.from(new Uint8Array(a)).map((e=>e.toString(16).padStart(2,"0"))).join("")},y=/[<>:"\\|?*\x00-\x1F]/;const g=Symbol("storage-name"),b=Symbol("idb");class k{constructor(e="public"){return this[g]="main",this[b]=new Promise((t=>{let a=indexedDB.open(`ever-cache-${e}`);a.onsuccess=e=>{t(e.target.result)},a.onupgradeneeded=e=>{e.target.result.createObjectStore("main",{keyPath:"key"})}})),new Proxy(this,x)}async setItem(e,t){return E(this,(a=>a.put({key:e,value:t}))).then((()=>!0))}async getItem(e){try{return E(this,(t=>t.get(e)),"readonly").then((e=>{const{result:t}=e.target;return t?t.value:null}))}catch(e){}}async removeItem(e){return E(this,(t=>t.delete(e))).then((()=>!0))}async clear(){return E(this,(e=>e.clear())).then((()=>!0))}async key(e){return E(this,(e=>e.getAllKeys())).then((t=>t.target.result[e]))}get length(){return E(this,(e=>e.count())).then((e=>e.target.result))}entries(){return{[Symbol.asyncIterator]:()=>{let e,t;const a=()=>{t=new Promise((t=>e=t))};return a(),E(this,(e=>e.openCursor()),"readonly",(t=>e(t.target.result))),{async next(){const e=await t;if(!e)return{done:!0};a();const{key:n,value:r}=e.value;return e.continue(),{value:[n,r],done:!1}}}}}}async*keys(){for await(let[e,t]of this.entries())yield e}async*values(){for await(let[e,t]of this.entries())yield t}}const v=new Set(Object.getOwnPropertyNames(k.prototype)),x={get:(e,t,a)=>v.has(t)||"symbol"==typeof t?Reflect.get(e,t,a):e.getItem(t),set:(e,t,a)=>e.setItem(t,a),deleteProperty:(e,t)=>e.removeItem(t)},E=async(e,t,a="readwrite",n)=>{const r=await e[b];return new Promise(((s,i)=>{const o=t(r.transaction([e[g]],a).objectStore(e[g]));o.onsuccess=e=>{if(n){const t=n(e);t&&s(t)}else s(e)},o.onerror=e=>{i(e)}}))};new k;const T="undefined"!=typeof $;!T||$.stanz([]);const j=T?$.stanz([]):[];new EventTarget;const D=T?$.stanz([]):[];T||(D.watchTick=()=>{});const I={},P={};D.watchTick((()=>{D.length>100&&D.splice(70)}),100);const A=new k("noneos-blocks-data");let _=null;const B=async()=>{const e=[];try{for await(let[t,a]of A.entries()){Date.now()-a.time>6e5&&e.push(t)}const t=await H("local/caches/blocks");e.length&&await Promise.all(e.map((async e=>{await A.removeItem(e);const a=await t.get(e);a&&await a.remove()})))}catch(e){console.error(e)}return clearTimeout(_),_=setTimeout((()=>B()),6e4),e};B();const C=async({data:e,path:t,reason:a,userId:n})=>{const r=await(async(e,t=1048576)=>{let a;if("string"==typeof e)a=new Blob([(new TextEncoder).encode(e)],{type:"text/plain"});else if(e instanceof Blob)a=e;else{if(!(e instanceof ArrayBuffer||e instanceof Uint8Array))throw new Error("Input must be a string, Blob, ArrayBuffer, or Uint8Array");a=new Blob([e],{type:"application/octet-stream"})}const n=[];for(let e=0;e<a.size;e+=t){const r=a.slice(e,e+t);n.push(r)}return n})(e,131072);return await N(r,{reason:a,reasonData:{path:t,userId:n}})},M=async e=>(e[0],Uint8Array,new Blob(e)),N=async(e,{reason:t,reasonData:a})=>{const n=await H("local/caches/blocks",{create:"dir"}),r=await Promise.all(e.map((async e=>{const t=await m(e);A.setItem(t,{time:Date.now()});const a=await n.get(t,{create:"file"});return await a.write(e),P[t]&&P[t].resolve(e),t})));return D.unshift({type:"save",hashs:r,time:Date.now(),reason:t,reasonData:a}),r},S=async(e,{reason:t,reasonData:a})=>{const n=await H("local/caches/blocks",{create:"dir"}),r=[],s=await Promise.all(e.map((async e=>{const t=await n.get(e);return t?(r.push(e),{hash:e,data:await t.file()}):{hash:e}})));return D.unshift({type:"get",hashs:e,time:Date.now(),reasonData:{exists:r,...a},reason:t}),s};class z{constructor(){}async flat(){return d(this)}async _saveCache({options:e}){const t=await this.file(e);return await C({data:t,reason:"save-cache",path:this.path,userId:this.__remote_user})}async _writeByCache({hashs:e,userId:t}){const a=await(async({hashs:e,userId:t,reason:a,path:n})=>{let r;t&&(r=j.find((e=>e.userId===t)));const s={path:n};r&&(s.userId=r.userId);const i=await S(e,{reason:a,reasonData:s}),o=[];i.forEach((e=>{e.data||o.push(e.hash)})),o.length&&r.send({type:"get-block",path:n,hashs:o});const c=await Promise.all(i.map((async e=>{const{hash:t,data:a}=e;if(a)return a;let n=I[t];return n||(n=I[t]=new Promise(((e,a)=>{let n=()=>{n=null,delete I[t],delete P[t]};P[t]={resolve(t){e(t),n()},reject(e){a(e),n()}}}))),n})));return await M(c)})({hashs:e,userId:t,path:this.path,reason:"remote-write-cache"});return await this.write(a)}}class L extends z{#e;#t;#a;#n;#r;#s;constructor(e,t){super(),this.#e=e,this.#t=t}get id(){return this.#e}get path(){return this.#a}get name(){return this.#n}get kind(){return this.#t}get createTime(){return this.#r}get lastModified(){return this.#s||null}async root(){let e=await h(this,"root");for(;"root"!==e.parent;)e=await s({key:e.parent});const t=await new O(e.key);return await t.refresh(),t}async parent(){const e=await h(this,"parent");if("root"===e.parent)return null;const t=new O(e.parent);return await t.refresh(),t}async moveTo(e,t){[e,t]=await u({target:e,name:t,self:this});const a=await h(this,"move");a.parent=e.id,a.name=t.toLowerCase(),a.realName=t,await o({datas:[a]}),await this.refresh()}async copyTo(e,t,a){if([e,t]=await u({target:e,name:t,self:this}),!(e instanceof L))return p({source:this,target:e,name:t,callback:a});let n;switch(this.kind){case"dir":n=await e.get(t,{create:"dir"});for await(let[e,t]of this.entries())await t.copyTo(n,e);break;case"file":n=await e.get(t,{create:"file"});const a=await h(this,"move"),r=await s({key:n.id}),i=r.hashs=a.hashs;await o({datas:[{...a,...r},...i.map(((e,t)=>({key:`${r.key}-${t}`,hash:e,type:"block"})))]})}return await l(e.id),n}async remove(e){const a=await h(this,"remove");if("root"===a.parent)throw t("notDeleteRoot",{name:this.name});"dir"===this.kind&&await this.forEach((async t=>{await t.remove(e)}));const n=a.hashs||[],r=[a.key];n.forEach(((e,t)=>{r.push(`${a.key}-${t}`)})),await o({removes:r}),n.length&&await c(n),e&&e({type:"remove",path:this.path})}async refresh(){const e=await h(this,"refresh");this.#r=e.createTime,this.#s=e.lastModified,this.#n=e.realName||e.name;const t=[e.realName||e.name];let a=e;for(;"root"!==a.parent;)a=await s({key:a.parent}),t.unshift(a.realName||a.name);return this.#a=t.join("/"),{createTime:e.createTime,lastModified:e.lastModified}}async size(){const e=await h(this,"size");if("file"===e.type)return e.size}toJSON(){const e={};return["createTime","id","kind","lastModified","name","path"].forEach((t=>{e[t]=this[t]})),e}get _mark(){return"db"}}class R extends L{constructor(e){super(e,"file")}async write(e,t){const a=await this.createWritable(),n=e.length||e.size||e.byteLength||0,r=Math.ceil(n/f);return a.onbeforewrite=e=>{t&&t({...e,length:r,type:"write-file-start"})},a.onwrite=e=>{t&&t({...e,length:r,type:"write-file-end"})},await a.write(e),await a.close(),!0}async createWritable(){return new U(this.id,this.path)}async read(e,t){const a=await h(this,"读取数据"),{hashs:n}=a;let r=[];if(t&&(t.start||t.end)){let e=Math.floor(t.start/f),a=Math.floor(t.end/f);r=await Promise.all(n.map((async(n,r)=>{let i;if(r>=e&&r<=a){i=(await s({storename:"blocks",key:n})).chunk,e===a?i=i.slice(t.start-r*f,t.end-r*f):r===e?i=i.slice(-1*((e+1)*f-t.start)):r===a&&(i=i.slice(0,t.end-a*f))}if(i)return new Blob([i])}))),r=r.filter((e=>!!e))}else n&&(r=await Promise.all(n.map((async(e,t)=>{const a=await s({storename:"blocks",key:e}),{chunk:n}=a;return new Blob([n])}))));const i=new Blob(r);return await(({blobData:e,type:t,data:a,isChunk:n})=>{if("text"!==t)return"file"===t?n?e:new File([e],a.name,{lastModified:a.lastModified}):"base64"===t?new Promise((t=>{const a=new FileReader;a.onload=()=>{t(a.result)},a.readAsDataURL(e)})):e;try{return new Response(e).text()}catch(e){throw e}})({blobData:i,type:e,data:{name:this.name},isChunk:t?.start||t?.end})}file(e){return this.read("file",e)}text(e){return this.read("text",e)}buffer(e){return this.read("buffer",e)}base64(e){return this.read("base64",e)}async hash(){const e=await this._getHashs();return await m(e.join(""))}async _getHashs(){const e=await s({key:this.id});return e?e.hashs:null}}class U{#i;#o=new ArrayBuffer;#c=[];#h=0;#a;constructor(e,t){this.#i=e,this.#a=t}async write(e){let t;if("string"==typeof e)t=(new TextEncoder).encode(e).buffer;else if(e instanceof Blob)t=await e.arrayBuffer();else if(e instanceof ArrayBuffer)t=e;else{if(!(e instanceof Uint8Array))throw new Error("Input must be a string, File object or ArrayBuffer object");t=e.buffer}for(this.#h+=t.byteLength,this.#o=function(e,t){const a=e.byteLength+t.byteLength,n=new ArrayBuffer(a),r=new Uint8Array(n);return r.set(new Uint8Array(e),0),r.set(new Uint8Array(t),e.byteLength),n}(this.#o,t);this.#o.byteLength>f;){const e=this.#o.slice(0,f);this.#o=this.#o.slice(f);const t=await this._writeChunk(e);this.#c.push(t)}}async _writeChunk(e){const t=await m(e),a=await s({storename:"blocks",key:t}),n={path:this.#a,index:this.#c.length,hash:t,exited:a};return this.onbeforewrite&&this.onbeforewrite({type:"onbeforewrite",...n}),a||await o({storename:"blocks",datas:[{hash:t,chunk:e}]}),this.onwrite&&this.onwrite({type:"onwrite",...n}),t}async close(){const e=await h({id:this.#i},"write");if(e){if(this.#o.byteLength>0){const e=await this._writeChunk(this.#o);this.#c.push(e)}{const t=e.hashs||[],a=this.#c,n=this.#h,r=[];for(let e=0;e<t.length;e++)e>=a.length&&r.push(`${this.#i}-${e}`);await o({datas:[{...e,lastModified:Date.now(),hashs:a,size:n},...a.map(((e,t)=>({type:"block",key:`${this.#i}-${t}`,hash:e})))],removes:r}),t.length&&await c(t),await l(e.parent)}}else await this.abort()}async abort(){this.#c&&await c(this.#c)}}class O extends L{constructor(e){super(e,"dir")}async get(e,a){if(!function(e){return!y.test(e)}(e))throw t("pathInvalid",{path:e});await h(this,"get");const r=e.split("/");if(a&&a.create&&"file"!==a.create&&"dir"!==a.create)throw t("invalidCreateType");let i=this;if(r.length>1)for(const e of r.slice(0,-1)){let n=i;if(i=await i.get(e,{create:a?.create?"dir":void 0}),!i)throw await n.refresh(),t("pathNotFound",{path:n.path+"/"+e})}let c=r.slice(-1)[0],p=await s({index:"parent_and_name",key:[i.id,c.toLowerCase()]});if(a&&a.create&&!p){const e=Date.now();p={createTime:e,lastModified:e,key:n(),realName:c,name:c.toLowerCase(),parent:i.id,type:a.create},await o({datas:[p]}),await l(i.id)}if(a&&a.create&&a.create!==p.type)throw t("targetAnotherType",{path:i.path+"/"+c,exitedType:p.type,targetType:a.create});return await q(p)}async*keys(){h(this,"keys");const e=await F(this.id);for(let t of e)yield t.name}async*entries(){h(this,"entries");const e=await F(this.id);for(let t of e)yield[t.name,await q(t)]}async*values(){h(this,"values");for await(let[,e]of this.entries())yield e}async forEach(e){h(this,"forEach");const t=await F(this.id);let a=0;for(let n of t)await e(await q(n),a),a++}async length(){h(this,"length");return await s({key:this.id,index:"parent",method:"count"})}}const F=async e=>await s({key:e,index:"parent",method:"getAll"}),q=async e=>{let t=null;if(e){switch(e.type){case"dir":t=new O(e.key);break;case"file":t=new R(e.key)}await t.refresh()}return t},W=(async()=>{await(async e=>{await s({index:"parent_and_name",key:["root",e]})||await o({datas:[{key:n(),parent:"root",name:e,createTime:Date.now()}]})})("local")})(),H=async(e,a)=>{const n=e.split("/");if(!n.length)throw t("pathEmpty");if(""===n[0])throw t("rootEmpty");await W;const r=await s({index:"parent_and_name",key:["root",n[0]]});if(!r)throw t("rootNotExist",{rootname:n[0]});const i=new O(r.key);return 1===n.length?(await i.refresh(),i):i.get(n.slice(1).join("/"),a)},J=async({request:e})=>{const{pathname:t}=new URL(e.url),a=decodeURIComponent(t.replace(/^\/\$\//,"")),n=a.split("/");if(!(3!==n.length||"apps"!==n[0]&&"packages"!==n[0]||"app"!==n[2]&&"appdebug"!==n[2]))return K({pathname:t,path:a});const r=await H(a);let s=await r.file();const i={},o=a.split(".").pop();return/^\/\$\/apps\//.test(t)&&"html"===o&&"index.html"===r.name?i["Content-Type"]="text/html; charset=utf-8":i["Content-Type"]=(e=>{switch(e){case"html":case"htm":case"txt":case"md":return"text/plain; charset=utf-8";case"js":case"mjs":return"application/javascript; charset=utf-8";case"json":return"application/json; charset=utf-8";case"css":return"text/css; charset=utf-8";case"xml":return"application/xml; charset=utf-8";case"svg":return"image/svg+xml; charset=utf-8";case"csv":return"text/csv; charset=utf-8";case"ics":return"text/calendar; charset=utf-8";case"pdf":return"application/pdf; charset=utf-8";case"doc":case"docx":return"application/msword; charset=utf-8";case"xls":case"xlsx":return"application/vnd.ms-excel; charset=utf-8";case"ppt":case"pptx":return"application/vnd.ms-powerpoint; charset=utf-8";case"zip":return"application/zip; charset=utf-8";case"gz":return"application/gzip; charset=utf-8";case"tar":return"application/x-tar; charset=utf-8";case"jpg":case"jpeg":return"image/jpeg";case"png":return"image/png";case"gif":return"image/gif";case"bmp":case"bmp":return"image/bmp";case"ico":return"image/x-icon";case"webp":return"image/webp";case"mp3":return"audio/mpeg";case"wav":return"audio/wav";case"mp4":case"m4v":return"video/mp4";case"mov":return"video/quicktime";case"avi":return"video/x-msvideo";default:return"application/octet-stream"}})(o),new Response(s,{status:200,headers:i})},K=async({pathname:e,path:t})=>{let a;const n=t.split("/"),r=n.slice(0,-1).join("/"),s="appdebug"===n.slice(-1)[0];try{a=await H(`${r}/app.json`),a=JSON.parse(await a.text())}catch(e){a=await fetch(`/${r}/app.json`).then((e=>e.json()))}return new Response(`<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="apple-mobile-web-app-capable" content="yes" />\n    <meta name="mobile-web-app-capable" content="yes" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />\n    <title>${a.name}</title>\n    <link rel="shortcut icon" href="${a.icon}">\n    <link rel="apple-touch-icon" href="${a.icon}" />\n    <script src="/packages/libs/ofa/ofa.js"${s?" debug":""}><\/script>\n    <script src="/packages/libs/ofa/router.min.js"><\/script>\n    <script src="/packages/pui/init.js" type="module"><\/script>\n    <style>\n      html,\n      body {\n        margin: 0;\n        padding: 0;\n        height: 100%;\n      }\n\n      o-app {\n        height: 100%;\n      }\n    </style>\n  </head>\n  <body>\n    <o-router fix-body>\n      <o-app src="${a.config}"></o-app>\n    </o-router>\n    <o-root-provider name="pui" theme="dark"></o-root-provider>\n    <o-root-provider name="clipboard" type="no"></o-root-provider>\n  </body>\n</html>\n    `,{status:200,headers:{"Content-Type":"text/html; charset=utf-8"}})};self.addEventListener("fetch",(e=>{const{request:t}=e,{pathname:a,origin:n}=new URL(t.url);location.origin===n&&("/"===a||"/index.html"===a?e.respondWith((async e=>{const t=await caches.open("noneos-default-cache");let a=await t.match(e);return a?a.clone():(a=await fetch(e),200===a.status&&t.put(e,a.clone()),a)})(a)):/^\/\$/.test(a)?e.respondWith((async()=>{try{return await J({request:t})}catch(e){return console.error(e),new Response(e.stack||e.toString(),{status:404})}})()):/^\/packages\//.test(a)&&e.respondWith((async()=>{try{return await J({request:{url:`${n}/$${a}`}})}catch(e){return fetch(t.url)}})()))})),self.addEventListener("install",(()=>{self.skipWaiting(),console.log("NoneOS installation successful")})),self.addEventListener("activate",(()=>{self.clients.claim(),console.log("NoneOS server activation successful")}))}();
