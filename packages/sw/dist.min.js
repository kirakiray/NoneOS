!function(){"use strict";const e={pathEmpty:"文件路径不能为空",indexErr:"在数据库{dbname}的{storename}表中没有找到索引{key}",setDataErr:"设置数据出错",findDataErr:"查找数据出错",getDataErr:"获取数据出错",rootEmpty:"不允许使用 '/' 开头的路径",rootNotExist:"根目录 {rootname} 不存在",pathNotFound:"未找到文件夹:{path}",storeNotExistMethod:"store中不存在方法 {method}",invalidCreateType:"create必须等于'file'或'dir'",notDeleteRoot:"不能直接删除根节点{name}",deleted:"当前handle已被删除，不能使用{name}；旧地址为:{path}",exitedName:"操作失败，{name}已经存在",tolowcase:"文件系统对大小写不敏感，{oldName}将会被转为{newName}",writefile:"写入文件内容失败:{path}",noPicker:"当前浏览器不支持文件选择",targetAnotherType:"{path} 已经是一个'{exitedType}'，不能创建为'{targetType}'",notMoveToChild:"{targetPath} 是 {path} 的子目录，不能移动到自己的子目录"},t=(t,a,n)=>{let r,s=e[t];if(a)for(let e in a)s=s.replace(new RegExp(`{${e}}`,"g"),a[e]);return r=n?new Error(s,{cause:n}):new Error(s),r.code=t,r},a={};function n(e=10){const t=new Uint8Array(e);return crypto.getRandomValues(t),Array.from(t,(e=>("0"+e.toString(32)).slice(-2))).join("")}const r=async(e="noneos_fs_defaults")=>(a[e]||(a[e]=new Promise((t=>{const n=indexedDB.open(e);n.onsuccess=async n=>{const r=n.target.result;r.onclose=()=>{a[e]=null},t(r)},n.onupgradeneeded=e=>{const t=e.target.result,a=t.createObjectStore("main",{keyPath:"key"});a.createIndex("parent","parent",{unique:!1}),a.createIndex("parent_and_name",["parent","name"],{unique:!0}),a.createIndex("hash","hash",{unique:!1}),t.createObjectStore("blocks",{keyPath:"hash"})},n.onerror=t=>{throw new Event(e+" creation error",{cause:t.error})}}))),a[e]),s=async({dbname:e="noneos_fs_defaults",storename:a="main",index:n,all:s=!1,method:i="get",key:o})=>{let c=await(async({storename:e,index:a,dbname:n})=>{let s=(await r(n)).transaction([e],"readonly").objectStore(e);if(a)try{s=s.index(a)}catch(r){throw t("indexErr",{dbname:n,storename:e,key:a},r)}return s})({storename:a,index:n,dbname:e});if(!c[i])throw t("storeNotExistMethod",{method:i});return new Promise(((e,a)=>{c=c[i](o),c.onsuccess=t=>{e(t.target.result)},c.onerror=e=>{a(t("getDataErr",null,e.target.error))}}))},i=new Map,o=async({dbname:e="noneos_fs_defaults",storename:a="main",datas:n,removes:s})=>{if(!n?.length&&!s?.length)return!0;const o=await r(e);return new Promise(((e,r)=>{const c=o.transaction([a],"readwrite");c.oncomplete=t=>{n&&n.forEach((e=>{e.parent&&i.delete(`${e.parent}-${e.name}`)})),e(!0)},c.onerror=e=>{r(t("setDataErr",null,e.target.error))};const l=c.objectStore(a);n&&n.forEach((e=>{if(e.parent){const t=i.get(`${e.parent}-${e.name}`);if(t){const a=t;Object.assign(e,a)}else i.set(`${e.parent}-${e.name}`,e)}l.put(e)})),s&&s.length&&s.forEach((e=>l.delete(e)))}))},c=async e=>{const t=[];await Promise.all(e.map((async e=>{!await s({index:"hash",key:e})&&t.push(e)}))),t.length&&await o({storename:"blocks",removes:t})},l=async(e,a)=>{const n=await s({key:e.id});if(!n)throw t("deleted",{name:a,path:e.path},e);return n},h=async e=>{const t=[],a=Date.now();let n=e;for(;n;){const e=await s({key:n});if(!e)break;e.lastModified=a,t.push(e),n=e.parent}await o({datas:t})};class p{#e;#t;#a;#n;#r;#s;constructor(e,t){this.#e=e,this.#t=t}get id(){return this.#e}get path(){return this.#a}get name(){return this.#n}get kind(){return this.#t}get createTime(){return this.#r}get lastModified(){return this.#s||null}async root(){let e=await l(this,"root");for(;"root"!==e.parent;)e=await s({key:e.parent});const t=await new g(e.key);return await t.refresh(),t}async parent(){const e=await l(this,"parent");if("root"===e.parent)return null;const t=new g(e.parent);return await t.refresh(),t}async moveTo(e,t){[e,t]=await d({target:e,name:t,self:this});const a=await l(this,"move");a.parent=e.id,a.name=t.toLowerCase(),a.realName=t,await o({datas:[a]}),await this.refresh()}async copyTo(e,t){let a;switch([e,t]=await d({target:e,name:t,self:this}),this.kind){case"dir":a=await e.get(t,{create:"dir"});for await(let[e,t]of this.entries())await t.copyTo(a,e);break;case"file":a=await e.get(t,{create:"file"});const n=await l(this,"move"),r=await s({key:a.id}),i=r.hashs=n.hashs;await o({datas:[{...n,...r},...i.map(((e,t)=>({key:`${r.key}-${t}`,hash:e,type:"block"})))]})}return await h(e.id),a}async remove(){const e=await l(this,"remove");if("root"===e.parent)throw t("notDeleteRoot",{name:this.name});"dir"===this.kind&&await this.forEach((async e=>{await e.remove()}));const a=e.hashs||[],n=[e.key];a.forEach(((t,a)=>{n.push(`${e.key}-${a}`)})),await o({removes:n}),a.length&&await c(a)}async refresh(){const e=await l(this,"refresh");this.#r=e.createTime,this.#s=e.lastModified,this.#n=e.realName||e.name;const t=[e.realName||e.name];let a=e;for(;"root"!==a.parent;)a=await s({key:a.parent}),t.unshift(a.realName||a.name);this.#a=t.join("/")}async size(){const e=await l(this,"size");if("file"===e.type)return e.size}}const d=async({target:e,name:a,self:n})=>{"string"==typeof e&&(a=e,e=await n.parent()),a||(a=n.name);let r=!1;for await(let t of e.keys())if(a===t){r=1;break}if(r)throw t("exitedName",{name:`${a}(${e.path}/${a})`});if(function(e,t){if(e===t)return!1;const a=t.split("/").filter((e=>e.length)),n=e.split("/").filter((e=>e.length));return a.every(((e,t)=>n[t]===e))}(e.path,n.path))throw t("notMoveToChild",{targetPath:e.path,path:n.path});return[e,a]};const u=1048576;class f extends p{constructor(e){super(e,"file")}async write(e,t){const a=await l(this,"write"),n=t?.process||(()=>{}),r=await m(e),i=[],p=e.length||e.size||0;await Promise.all(r.map((async(e,t)=>{const a=await y(e);i[t]=a;const c=await s({storename:"blocks",key:a});c||await o({storename:"blocks",datas:[{hash:a,chunk:e}]}),n({index:t,length:r.length,hash:a,exited:c})})));const d=a.hashs||[],u=[];for(let e=0;e<d.length;e++)e>=i.length&&u.push(`${this.id}-${e}`);await o({datas:[{...a,lastModified:e?.lastModified||Date.now(),hashs:i,size:p},...i.map(((e,t)=>({type:"block",key:`${this.id}-${t}`,hash:e})))],removes:u}),d.length&&await c(d),await h(a.parent)}async read(e,t){const a=await l(this,"读取数据"),{hashs:n}=a;let r=[];if(t&&(t.start||t.end)){let e=Math.floor(t.start/u),a=Math.floor(t.end/u);r=await Promise.all(n.map((async(n,r)=>{let i;if(r>=e&&r<=a){i=(await s({storename:"blocks",key:n})).chunk,e===a?i=i.slice(t.start-r*u,t.end-r*u):r===e?i=i.slice(-1*((e+1)*u-t.start)):r===a&&(i=i.slice(0,t.end-a*u))}return i}))),r=r.filter((e=>!!e))}else n&&(r=await Promise.all(n.map((async(e,t)=>{const{chunk:a}=await s({storename:"blocks",key:e});return a}))));const i=w(r);return"text"===e?(new TextDecoder).decode(i):"file"===e?t?.start||t?.end?new Blob([i.buffer]):new File([i.buffer],a.name,{lastModified:a.lastModified}):"base64"===e?new Promise((e=>{const t=new File([i.buffer],a.name),n=new FileReader;n.onload=()=>{resolve(n.result)},n.readAsDataURL(t)})):i.buffer}file(e){return this.read("file",e)}text(e){return this.read("text",e)}buffer(e){return this.read("buffer",e)}base64(e){return this.read("base64",e)}}const m=async e=>{let t;if("string"==typeof e)t=(new TextEncoder).encode(e).buffer;else if(e instanceof File)t=await e.arrayBuffer();else{if(!(e instanceof ArrayBuffer))throw new Error("Input must be a string, File object or ArrayBuffer object");t=e}const a=[];for(let e=0;e<t.byteLength;e+=u){const n=t.slice(e,e+u);a.push(n)}return a},w=e=>{const t=e.reduce(((e,t)=>e+t.byteLength),0),a=new Uint8Array(t);let n=0;return e.forEach((e=>{a.set(new Uint8Array(e),n),n+=e.byteLength})),a},y=async e=>{const t=await crypto.subtle.digest("SHA-256",e),a=Array.from(new Uint8Array(t)).map((e=>e.toString(16).padStart(2,"0"))).join(""),n=Math.floor(e.byteLength/2);return a+new Uint8Array(e.slice(n,n+1))[0].toString(16)};class g extends p{constructor(e){super(e,"dir")}async get(e,a){await l(this,"get");const r=e.split("/");if(a&&a.create&&"file"!==a.create&&"dir"!==a.create)throw t("invalidCreateType");let i=this;if(r.length>1)for(const e of r.slice(0,-1)){let n=i;if(i=await i.get(e,{create:a?.create?"dir":void 0}),!i)throw await n.refresh(),t("pathNotFound",{path:n.path+"/"+e})}let c=r.slice(-1)[0],p=await s({index:"parent_and_name",key:[i.id,c.toLowerCase()]});if(a&&a.create&&!p){const e=Date.now();p={createTime:e,lastModified:e,key:n(),realName:c,name:c.toLowerCase(),parent:i.id,type:a.create},await o({datas:[p]}),await h(i.id)}if(a&&a.create&&a.create!==p.type)throw t("targetAnotherType",{path:i.path+"/"+c,exitedType:p.type,targetType:a.create});return await b(p)}async*keys(){l(this,"keys");const e=await k(this.id);for(let t of e)yield t.name}async*entries(){l(this,"entries");const e=await k(this.id);for(let t of e)yield[t.name,await b(t)]}async*values(){l(this,"values");for await(let[,e]of this.entries())yield e}async forEach(e){l(this,"forEach");const t=await k(this.id);let a=0;for(let n of t)await e(await b(n),a),a++}async length(){l(this,"length");return await s({key:this.id,index:"parent",method:"count"})}}const k=async e=>await s({key:e,index:"parent",method:"getAll"}),b=async e=>{let t=null;if(e){switch(e.type){case"dir":t=new g(e.key);break;case"file":t=new f(e.key)}await t.refresh()}return t},x=(async()=>{await(async e=>{await s({index:"parent_and_name",key:["root",e]})||await o({datas:[{key:n(),parent:"root",name:e,createTime:Date.now()}]})})("local")})(),v=async(e,a)=>{const n=e.split("/");if(!n.length)throw t("pathEmpty");if(""===n[0])throw t("rootEmpty");await x;const r=await s({index:"parent_and_name",key:["root",n[0]]});if(!r)throw t("rootNotExist",{rootname:n[0]});const i=new g(r.key);return 1===n.length?(await i.refresh(),i):i.get(n.slice(1).join("/"),a)},E=async({request:e})=>{const{pathname:t}=new URL(e.url),a=decodeURIComponent(t.replace(/^\/\$\//,"")),n=a.split("/");if(!(3!==n.length||"apps"!==n[0]&&"packages"!==n[0]||"app"!==n[2]&&"appdebug"!==n[2]))return $({pathname:t,path:a});const r=await v(a);let s=await r.file();const i={},o=a.split(".").pop();return/^\/\$\/apps\//.test(t)&&"html"===o&&"index.html"===r.name?i["Content-Type"]="text/html; charset=utf-8":i["Content-Type"]=(e=>{switch(e){case"html":case"htm":case"txt":case"md":return"text/plain; charset=utf-8";case"js":case"mjs":return"application/javascript; charset=utf-8";case"json":return"application/json; charset=utf-8";case"css":return"text/css; charset=utf-8";case"xml":return"application/xml; charset=utf-8";case"svg":return"image/svg+xml; charset=utf-8";case"csv":return"text/csv; charset=utf-8";case"ics":return"text/calendar; charset=utf-8";case"pdf":return"application/pdf; charset=utf-8";case"doc":case"docx":return"application/msword; charset=utf-8";case"xls":case"xlsx":return"application/vnd.ms-excel; charset=utf-8";case"ppt":case"pptx":return"application/vnd.ms-powerpoint; charset=utf-8";case"zip":return"application/zip; charset=utf-8";case"gz":return"application/gzip; charset=utf-8";case"tar":return"application/x-tar; charset=utf-8";case"jpg":case"jpeg":return"image/jpeg";case"png":return"image/png";case"gif":return"image/gif";case"bmp":case"bmp":return"image/bmp";case"ico":return"image/x-icon";case"webp":return"image/webp";case"mp3":return"audio/mpeg";case"wav":return"audio/wav";case"mp4":case"m4v":return"video/mp4";case"mov":return"video/quicktime";case"avi":return"video/x-msvideo";default:return"application/octet-stream"}})(o),new Response(s,{status:200,headers:i})},$=async({pathname:e,path:t})=>{let a;const n=t.split("/"),r=n.slice(0,-1).join("/"),s="appdebug"===n.slice(-1)[0];try{a=await v(`${r}/app.json`),a=JSON.parse(await a.text())}catch(e){a=await fetch(`/${r}/app.json`).then((e=>e.json()))}return new Response(`<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="apple-mobile-web-app-capable" content="yes" />\n    <meta name="mobile-web-app-capable" content="yes" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />\n    <title>${a.name}</title>\n    <link rel="shortcut icon" href="${a.icon}">\n    <link rel="apple-touch-icon" href="${a.icon}" />\n    <script src="/packages/ofa/ofa.js"${s?" debug":""}><\/script>\n    <script src="/packages/ofa/router.min.js"><\/script>\n    <script src="/packages/pui/init.js" type="module"><\/script>\n    <style>\n      html,\n      body {\n        margin: 0;\n        padding: 0;\n        height: 100%;\n      }\n\n      o-app {\n        height: 100%;\n      }\n    </style>\n  </head>\n  <body>\n    <o-router fix-body>\n      <o-app src="${a.config}"></o-app>\n    </o-router>\n    <o-root-provider name="pui" theme="dark"></o-root-provider>\n    <o-root-provider name="clipboard" type="no"></o-root-provider>\n  </body>\n</html>\n    `,{status:200,headers:{"Content-Type":"text/html; charset=utf-8"}})};self.addEventListener("fetch",(e=>{const{request:t}=e,{pathname:a,origin:n}=new URL(t.url);location.origin===n&&("/"===a||"/index.html"===a?e.respondWith((async e=>{const t=await caches.open("noneos-default-cache");let a=await t.match(e);return a?a.clone():(a=await fetch(e),200===a.status&&t.put(e,a.clone()),a)})(a)):/^\/\$/.test(a)?e.respondWith((async()=>{try{return await E({request:t})}catch(e){return console.error(e),new Response(e.stack||e.toString(),{status:404})}})()):/^\/packages\//.test(a)&&e.respondWith((async()=>{try{return await E({request:{url:`${n}/$${a}`}})}catch(e){return fetch(t.url)}})()))})),self.addEventListener("install",(()=>{self.skipWaiting(),console.log("NoneOS installation successful")})),self.addEventListener("activate",(()=>{self.clients.claim(),console.log("NoneOS server activation successful")}))}();
