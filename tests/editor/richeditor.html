<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rich Text Editor</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 20px;
        background-color: #f4f4f4;
      }
      .editor-container {
        width: 600px;
        min-height: 300px;
        border: 1px solid #ccc;
        padding: 10px;
        background-color: #fff;
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        outline: none;
        position: relative;
        line-height: 1.5;
      }
      .editor-line {
        min-height: 1.5em; /* Ensure lines have height even if empty */
        white-space: pre-wrap; /* Preserve whitespace and wrap text */
        word-wrap: break-word;
      }
      .cursor {
        display: inline-block;
        width: 2px;
        background-color: black;
        animation: blink 1s step-end infinite;
        vertical-align: text-bottom; /* Align cursor with text baseline */
        position: absolute;
      }
      @keyframes blink {
        from,
        to {
          background-color: transparent;
        }
        50% {
          background-color: black;
        }
      }
    </style>
  </head>
  <body>
    <h1>Simple Rich Text Editor</h1>
    <div id="editor" class="editor-container">
      <div class="editor-line"></div>
    </div>

    <script>
      const editor = document.getElementById("editor");
      let currentLine = editor.querySelector(".editor-line");
      let cursorElement;

      function createCursor() {
        cursorElement = document.createElement("span");
        cursorElement.classList.add("cursor");
        currentLine.appendChild(cursorElement);
        updateCursorPosition();
      }

      function updateCursorPosition() {
        if (!cursorElement) return;

        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          const rect = range.getBoundingClientRect();
          const editorRect = editor.getBoundingClientRect();

          // Calculate cursor position relative to the editor container
          cursorElement.style.left = `${
            rect.left - editorRect.left + window.scrollX
          }px`;
          cursorElement.style.top = `${
            rect.top - editorRect.top + window.scrollY
          }px`;
          cursorElement.style.height = `${
            rect.height ||
            parseFloat(getComputedStyle(currentLine).fontSize) * 1.5
          }px`;
        }
      }

      function placeCursorAtEnd(node) {
        const range = document.createRange();
        const selection = window.getSelection();
        range.selectNodeContents(node);
        range.collapse(false); // Collapse to the end
        selection.removeAllRanges();
        selection.addRange(range);
        currentLine = node;
        updateCursorPosition();
      }

      function placeCursorAtStart(node) {
        const range = document.createRange();
        const selection = window.getSelection();
        range.setStart(node, 0);
        range.collapse(true); // Collapse to the start
        selection.removeAllRanges();
        selection.addRange(range);
        currentLine = node;
        updateCursorPosition();
      }

      editor.addEventListener("focus", () => {
        if (!currentLine.hasChildNodes()) {
          placeCursorAtEnd(currentLine);
        } else if (!cursorElement) {
          createCursor();
        }
      });

      editor.addEventListener("blur", () => {
        if (cursorElement && cursorElement.parentNode) {
          cursorElement.parentNode.removeChild(cursorElement);
          cursorElement = null;
        }
      });

      editor.addEventListener("keydown", (e) => {
        e.preventDefault(); // Prevent default browser behavior

        const selection = window.getSelection();
        const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;

        if (!range) return;

        let textNode = range.startContainer;
        let offset = range.startOffset;

        // Ensure we are always working within an editor-line div
        if (
          textNode.nodeType === Node.TEXT_NODE &&
          textNode.parentNode.classList.contains("editor-line")
        ) {
          currentLine = textNode.parentNode;
        } else if (
          textNode.nodeType === Node.ELEMENT_NODE &&
          textNode.classList.contains("editor-line")
        ) {
          currentLine = textNode;
          // If the line is empty, ensure textNode is the line itself for insertion
          if (currentLine.childNodes.length === 0) {
            textNode = currentLine;
            offset = 0;
          } else if (offset < currentLine.childNodes.length) {
            textNode = currentLine.childNodes[offset];
            offset = 0; // Insert at the beginning of the child node
          } else {
            textNode = currentLine.lastChild || currentLine;
            offset = textNode.length || 0;
          }
        } else {
          // Fallback if selection is not directly in an editor-line
          currentLine = editor.querySelector(".editor-line");
          if (!currentLine) {
            currentLine = document.createElement("div");
            currentLine.classList.add("editor-line");
            editor.appendChild(currentLine);
          }
          placeCursorAtEnd(currentLine);
          textNode = currentLine;
          offset = currentLine.textContent.length;
        }

        if (e.key === "Enter") {
          const newLine = document.createElement("div");
          newLine.classList.add("editor-line");

          // Split the current line content
          const remainingText = textNode.textContent.substring(offset);
          textNode.textContent = textNode.textContent.substring(0, offset);
          newLine.textContent = remainingText;

          if (currentLine.nextSibling) {
            editor.insertBefore(newLine, currentLine.nextSibling);
          } else {
            editor.appendChild(newLine);
          }
          placeCursorAtStart(newLine);
        } else if (e.key === "Backspace") {
          if (offset > 0) {
            textNode.textContent =
              textNode.textContent.substring(0, offset - 1) +
              textNode.textContent.substring(offset);
            range.setStart(textNode, offset - 1);
            range.collapse(true);
          } else if (
            currentLine.previousSibling &&
            currentLine.previousSibling.classList.contains("editor-line")
          ) {
            const prevLine = currentLine.previousSibling;
            const prevLineLength = prevLine.textContent.length;
            prevLine.textContent += currentLine.textContent;
            editor.removeChild(currentLine);
            placeCursorAtEnd(prevLine);
          }
        } else if (e.key === "Delete") {
          if (offset < textNode.textContent.length) {
            textNode.textContent =
              textNode.textContent.substring(0, offset) +
              textNode.textContent.substring(offset + 1);
            range.setStart(textNode, offset);
            range.collapse(true);
          } else if (
            currentLine.nextSibling &&
            currentLine.nextSibling.classList.contains("editor-line")
          ) {
            const nextLine = currentLine.nextSibling;
            currentLine.textContent += nextLine.textContent;
            editor.removeChild(nextLine);
            placeCursorAtEnd(currentLine);
          }
        } else if (e.key === "ArrowLeft") {
          if (offset > 0) {
            range.setStart(textNode, offset - 1);
            range.collapse(true);
          } else if (
            currentLine.previousSibling &&
            currentLine.previousSibling.classList.contains("editor-line")
          ) {
            placeCursorAtEnd(currentLine.previousSibling);
          }
        } else if (e.key === "ArrowRight") {
          if (offset < textNode.textContent.length) {
            range.setStart(textNode, offset + 1);
            range.collapse(true);
          } else if (
            currentLine.nextSibling &&
            currentLine.nextSibling.classList.contains("editor-line")
          ) {
            placeCursorAtStart(currentLine.nextSibling);
          }
        } else if (e.key === "ArrowUp") {
          const prevLine = currentLine.previousSibling;
          if (prevLine && prevLine.classList.contains("editor-line")) {
            // Try to maintain horizontal position
            const currentRect = range.getBoundingClientRect();
            const prevLineChildren = Array.from(prevLine.childNodes);
            let bestNode = prevLine;
            let bestOffset = 0;
            let minDistance = Infinity;

            if (prevLineChildren.length > 0) {
              prevLineChildren.forEach((node) => {
                if (node.nodeType === Node.TEXT_NODE) {
                  for (let i = 0; i <= node.length; i++) {
                    const tempRange = document.createRange();
                    tempRange.setStart(node, i);
                    tempRange.collapse(true);
                    const tempRect = tempRange.getBoundingClientRect();
                    const distance = Math.abs(tempRect.left - currentRect.left);
                    if (distance < minDistance) {
                      minDistance = distance;
                      bestNode = node;
                      bestOffset = i;
                    }
                  }
                }
              });
            }
            range.setStart(bestNode, bestOffset);
            range.collapse(true);
            currentLine = prevLine;
          } else {
            placeCursorAtStart(currentLine);
          }
        } else if (e.key === "ArrowDown") {
          const nextLine = currentLine.nextSibling;
          if (nextLine && nextLine.classList.contains("editor-line")) {
            // Try to maintain horizontal position
            const currentRect = range.getBoundingClientRect();
            const nextLineChildren = Array.from(nextLine.childNodes);
            let bestNode = nextLine;
            let bestOffset = 0;
            let minDistance = Infinity;

            if (nextLineChildren.length > 0) {
              nextLineChildren.forEach((node) => {
                if (node.nodeType === Node.TEXT_NODE) {
                  for (let i = 0; i <= node.length; i++) {
                    const tempRange = document.createRange();
                    tempRange.setStart(node, i);
                    tempRange.collapse(true);
                    const tempRect = tempRange.getBoundingClientRect();
                    const distance = Math.abs(tempRect.left - currentRect.left);
                    if (distance < minDistance) {
                      minDistance = distance;
                      bestNode = node;
                      bestOffset = i;
                    }
                  }
                }
              });
            }
            range.setStart(bestNode, bestOffset);
            range.collapse(true);
            currentLine = nextLine;
          } else {
            placeCursorAtEnd(currentLine);
          }
        } else if (
          e.key.length === 1 &&
          !e.ctrlKey &&
          !e.metaKey &&
          !e.altKey
        ) {
          // Handle printable characters
          const char = e.key;
          const newText =
            textNode.textContent.substring(0, offset) +
            char +
            textNode.textContent.substring(offset);
          textNode.textContent = newText;
          range.setStart(textNode, offset + 1);
          range.collapse(true);
        }
        selection.removeAllRanges();
        selection.addRange(range);
        updateCursorPosition();
      });

      // Handle clicks to set cursor position
      editor.addEventListener("click", (e) => {
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          let targetLine = range.startContainer;
          if (targetLine.nodeType === Node.TEXT_NODE) {
            targetLine = targetLine.parentNode;
          }
          if (targetLine.classList.contains("editor-line")) {
            currentLine = targetLine;
            if (!cursorElement) {
              createCursor();
            }
            updateCursorPosition();
          }
        }
      });

      // Initial setup
      editor.setAttribute("tabindex", "0"); // Make the editor focusable
      createCursor();
      placeCursorAtEnd(currentLine);
    </script>
  </body>
</html>
