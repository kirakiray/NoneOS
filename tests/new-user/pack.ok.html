<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pack Test</title>
    <script src="/packages/libs/ofa/ofa.js" type="module"></script>
  </head>
  <body>
    <script type="module">
      import { test } from "/ok-test/main.js";
      import { pack, unpack } from "/packages/user/util/pack.js";

      await test("Basic Pack/Unpack Test", async () => {
        // åˆ›å»ºæµ‹è¯•å¯¹è±¡å’ŒäºŒè¿›åˆ¶æ•°æ®
        const testObj = {
          name: "æµ‹è¯•å¯¹è±¡",
          number: 42,
          isActive: true,
          nested: {
            text: "åµŒå¥—æ–‡æœ¬",
            value: 123.45,
          },
        };
        const testData = new Uint8Array([1, 2, 3, 4, 5]);

        // æ‰“åŒ…æ•°æ®
        const packed = pack(testObj, testData);

        // è§£åŒ…æ•°æ®
        const { obj, data } = unpack(packed);

        // éªŒè¯è½¬æ¢ç»“æœ
        const isNameEqual = obj.name === testObj.name;
        const isNumberEqual = obj.number === testObj.number;
        const isActiveEqual = obj.isActive === testObj.isActive;
        const isNestedTextEqual = obj.nested.text === testObj.nested.text;
        const isNestedValueEqual = obj.nested.value === testObj.nested.value;
        const isDataEqual = data.every(
          (value, index) => value === testData[index]
        );

        return {
          assert:
            isNameEqual &&
            isNumberEqual &&
            isActiveEqual &&
            isNestedTextEqual &&
            isNestedValueEqual &&
            isDataEqual,
          content: {
            message: "åŸºæœ¬æ‰“åŒ…è§£åŒ…æµ‹è¯•æˆåŠŸ",
            originalObj: testObj,
            originalData: testData,
            packed: packed,
            unpackedObj: obj,
            unpackedData: data,
            validations: {
              isNameEqual,
              isNumberEqual,
              isActiveEqual,
              isNestedTextEqual,
              isNestedValueEqual,
              isDataEqual,
            },
          },
        };
      });

      await test("Empty Object Test", async () => {
        // åˆ›å»ºç©ºå¯¹è±¡å’Œç©ºæ•°æ®
        const emptyObj = {};
        const emptyData = new Uint8Array(0);

        // æ‰“åŒ…æ•°æ®
        const packed = pack(emptyObj, emptyData);

        // è§£åŒ…æ•°æ®
        const { obj, data } = unpack(packed);

        // éªŒè¯è½¬æ¢ç»“æœ
        const isObjEmpty = Object.keys(obj).length === 0;
        const isDataEmpty = data.length === 0;

        return {
          assert: isObjEmpty && isDataEmpty,
          content: {
            message: "ç©ºå¯¹è±¡å’Œç©ºæ•°æ®æµ‹è¯•æˆåŠŸ",
            originalObj: emptyObj,
            originalData: emptyData,
            packed: packed,
            unpackedObj: obj,
            unpackedData: data,
            validations: {
              isObjEmpty,
              isDataEmpty,
            },
          },
        };
      });

      await test("Complex Data Test", async () => {
        // åˆ›å»ºå¤æ‚å¯¹è±¡å’Œå¤§æ•°æ®
        const complexObj = {
          id: Math.random().toString(36).substring(2, 15),
          timestamp: Date.now(),
          arrays: [1, 2, 3, 4, 5],
          nested: {
            deeply: {
              nested: {
                value: "deep nested value",
              },
            },
          },
          mixed: ["string", 123, true, null, { key: "value" }],
        };
        const complexData = crypto.getRandomValues(new Uint8Array(32));

        // æ‰“åŒ…æ•°æ®
        const packed = pack(complexObj, complexData);

        // è§£åŒ…æ•°æ®
        const { obj, data } = unpack(packed);

        // éªŒè¯è½¬æ¢ç»“æœ
        const isIdEqual = obj.id === complexObj.id;
        const isTimestampEqual = obj.timestamp === complexObj.timestamp;
        const isArraysEqual =
          JSON.stringify(obj.arrays) === JSON.stringify(complexObj.arrays);
        const isNestedEqual =
          obj.nested.deeply.nested.value ===
          complexObj.nested.deeply.nested.value;
        const isMixedEqual =
          JSON.stringify(obj.mixed) === JSON.stringify(complexObj.mixed);
        const isDataEqual = data.every(
          (value, index) => value === complexData[index]
        );

        return {
          assert:
            isIdEqual &&
            isTimestampEqual &&
            isArraysEqual &&
            isNestedEqual &&
            isMixedEqual &&
            isDataEqual,
          content: {
            message: "å¤æ‚æ•°æ®æµ‹è¯•æˆåŠŸ",
            originalObj: complexObj,
            originalData: Array.from(complexData),
            packedLength: packed.length,
            unpackedObj: obj,
            unpackedData: Array.from(data),
            validations: {
              isIdEqual,
              isTimestampEqual,
              isArraysEqual,
              isNestedEqual,
              isMixedEqual,
              isDataEqual,
            },
          },
        };
      });

      await test("Large Data Test", async () => {
        // åˆ›å»ºæµ‹è¯•å¯¹è±¡å’Œå¤§æ•°æ®
        const testObj = {
          message: "Large data test",
          size: 1024,
        };
        const largeData = crypto.getRandomValues(new Uint8Array(1024));

        // æ‰“åŒ…æ•°æ®
        const packed = pack(testObj, largeData);

        // è§£åŒ…æ•°æ®
        const { obj, data } = unpack(packed);

        // éªŒè¯è½¬æ¢ç»“æœ
        const isMessageEqual = obj.message === testObj.message;
        const isSizeEqual = obj.size === testObj.size;
        const isDataLengthEqual = data.length === largeData.length;
        const isDataEqual = data.every(
          (value, index) => value === largeData[index]
        );

        return {
          assert:
            isMessageEqual && isSizeEqual && isDataLengthEqual && isDataEqual,
          content: {
            message: "å¤§æ•°æ®æµ‹è¯•æˆåŠŸ",
            originalObj: testObj,
            originalDataLength: largeData.length,
            packedLength: packed.length,
            unpackedObj: obj,
            unpackedDataLength: data.length,
            validations: {
              isMessageEqual,
              isSizeEqual,
              isDataLengthEqual,
              isDataEqual,
            },
          },
        };
      });

      await test("Error Handling Test", async () => {
        try {
          // æµ‹è¯•æ— æ•ˆç¼“å†²åŒº
          const invalidBuffer = new Uint8Array([1, 2, 3]); // é•¿åº¦å°äº4
          unpack(invalidBuffer);
          return {
            assert: false,
            content: {
              message: "åº”è¯¥æŠ›å‡ºé”™è¯¯ä½†æ²¡æœ‰æŠ›å‡º",
            },
          };
        } catch (error) {
          return {
            assert: error.message === "Invalid buffer",
            content: {
              message: "é”™è¯¯å¤„ç†æµ‹è¯•æˆåŠŸ",
              errorMessage: error.message,
            },
          };
        }
      });

      await test("Unicode Text Test", async () => {
        // åˆ›å»ºåŒ…å«Unicodeå­—ç¬¦çš„å¯¹è±¡
        const unicodeObj = {
          chinese: "ä½ å¥½ä¸–ç•Œ",
          japanese: "ã“ã‚“ã«ã¡ã¯",
          emoji: "ğŸš€âœ¨ğŸŒŸ",
          mixed: "Hello ä¸–ç•Œ ğŸŒ",
        };
        const unicodeData = new TextEncoder().encode("Unicode data: ä½ å¥½ ğŸ‰");

        // æ‰“åŒ…æ•°æ®
        const packed = pack(unicodeObj, unicodeData);

        // è§£åŒ…æ•°æ®
        const { obj, data } = unpack(packed);

        // éªŒè¯è½¬æ¢ç»“æœ
        const isChineseEqual = obj.chinese === unicodeObj.chinese;
        const isJapaneseEqual = obj.japanese === unicodeObj.japanese;
        const isEmojiEqual = obj.emoji === unicodeObj.emoji;
        const isMixedEqual = obj.mixed === unicodeObj.mixed;
        const isDataEqual =
          new TextDecoder().decode(data) ===
          new TextDecoder().decode(unicodeData);

        return {
          assert:
            isChineseEqual &&
            isJapaneseEqual &&
            isEmojiEqual &&
            isMixedEqual &&
            isDataEqual,
          content: {
            message: "Unicodeæ–‡æœ¬æµ‹è¯•æˆåŠŸ",
            originalObj: unicodeObj,
            originalData: new TextDecoder().decode(unicodeData),
            unpackedObj: obj,
            unpackedData: new TextDecoder().decode(data),
            validations: {
              isChineseEqual,
              isJapaneseEqual,
              isEmojiEqual,
              isMixedEqual,
              isDataEqual,
            },
          },
        };
      });
    </script>
  </body>
</html>
