<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Buffer Data Test</title>
    <script src="/packages/libs/ofa/ofa.js" type="module"></script>
  </head>
  <body>
    <script type="module">
      import { test } from "/ok-test/main.js";
      import { toBuffer, toData } from "/packages/new-user/buffer-data.js";

      await test("Buffer Data Conversion Test", async () => {
        // 生成随机原始数据
        const originBuffer = crypto.getRandomValues(new Uint8Array(16)); // 128位 = 16字节

        // 创建测试信息对象
        const info = {
          message: "Original message " + Math.random(),
          timestamp: Date.now(),
        };

        // 将原始数据和信息对象转换为buffer
        const buffer = toBuffer(originBuffer, info);

        // 从buffer中解析出数据和信息
        const { data: parsedData, info: parsedInfo } = toData(buffer);

        // 验证转换结果
        const isArrayEqual = parsedData.every(
          (value, index) => value === originBuffer[index]
        );
        const isInfoEqual =
          parsedInfo.message === info.message &&
          parsedInfo.timestamp === info.timestamp;

        return {
          assert: isArrayEqual && isInfoEqual,
          content: {
            message: "Buffer数据转换测试成功",
            originData: Array.from(originBuffer),
            parsedData: Array.from(parsedData),
            originInfo: info,
            parsedInfo: parsedInfo,
            isArrayEqual,
            isInfoEqual,
          },
        };
      });

      await test("Buffer Data Empty Info Test", async () => {
        // 生成随机原始数据
        const originBuffer = crypto.getRandomValues(new Uint8Array(8));

        // 使用空对象作为信息
        const info = {};

        // 将原始数据和信息对象转换为buffer
        const buffer = toBuffer(originBuffer, info);

        // 从buffer中解析出数据和信息
        const { data: parsedData, info: parsedInfo } = toData(buffer);

        // 验证转换结果
        const isArrayEqual = parsedData.every(
          (value, index) => value === originBuffer[index]
        );
        const isInfoEqual = JSON.stringify(parsedInfo) === JSON.stringify(info);

        return {
          assert: isArrayEqual && isInfoEqual,
          content: {
            message: "Buffer数据空信息测试成功",
            originData: Array.from(originBuffer),
            parsedData: Array.from(parsedData),
            originInfo: info,
            parsedInfo: parsedInfo,
            isArrayEqual,
            isInfoEqual,
          },
        };
      });

      await test("Buffer Data Complex Info Test", async () => {
        // 生成随机原始数据
        const originBuffer = crypto.getRandomValues(new Uint8Array(32));

        // 创建复杂的信息对象
        const info = {
          id: Math.random().toString(36).substring(2, 15),
          nested: {
            value: Math.floor(Math.random() * 1000),
            array: [1, 2, 3, "test"],
            boolean: true,
          },
          timestamp: Date.now(),
          tags: ["tag1", "tag2", "tag3"],
        };

        // 将原始数据和信息对象转换为buffer
        const buffer = toBuffer(originBuffer, info);

        // 从buffer中解析出数据和信息
        const { data: parsedData, info: parsedInfo } = toData(buffer);

        // 验证转换结果
        const isArrayEqual = parsedData.every(
          (value, index) => value === originBuffer[index]
        );
        const isInfoEqual = JSON.stringify(parsedInfo) === JSON.stringify(info);

        return {
          assert: isArrayEqual && isInfoEqual,
          content: {
            message: "Buffer数据复杂信息测试成功",
            originData: Array.from(originBuffer),
            parsedData: Array.from(parsedData),
            originInfo: info,
            parsedInfo: parsedInfo,
            isArrayEqual,
            isInfoEqual,
          },
        };
      });
    </script>
  </body>
</html>
